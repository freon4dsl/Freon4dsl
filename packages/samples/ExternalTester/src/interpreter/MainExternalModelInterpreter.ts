// Generated by the Freon Language Generator.
// TEMPLATE: InterpreterBaseTemplate.interpreterInit(...)
// Will be overwritten with every generation.

import {
    type ConceptFunction,
    type FreInterpreter,
    type IMainInterpreter,
    InterpreterContext,
    InterpreterTracer,
    MainInterpreter,
    type OwningPropertyFunction,
    type FreNode,
    RtObject,
    RtError,
} from "@freon4dsl/core";

import { ExternalModelInterpreterInit } from "./gen/ExternalModelInterpreterInit.js";

const getPropertyFunction: OwningPropertyFunction = (node: Object) => {
    const index = (node as FreNode).freOwnerDescriptor().propertyIndex;
    return (node as FreNode).freOwnerDescriptor().propertyName + (index !== undefined ? "[" + index + "]" : "");
};

/**
 * Function that returns the concept name for `node`.
 * Used by the interpreter to find which evaluator should be use for each node.
 */
const getConceptFunction: ConceptFunction = (node: Object) => {
    if (node === undefined) {
        return "";
    }
    return (node as FreNode).freLanguageConcept();
};

/**
 * The facade around the actual interpreter to avoid improper usage.
 * Sets the functions used to access the expression tree.
 * Ensures all internal interpreter state is cleaned when creating a new instance.
 */
export class MainExternalModelInterpreter implements FreInterpreter {
    private static main: IMainInterpreter = null;

    constructor() {
        if (MainExternalModelInterpreter.main === null) {
            MainExternalModelInterpreter.main = MainInterpreter.instance(
                ExternalModelInterpreterInit,
                getConceptFunction,
                getPropertyFunction,
            );
        }
    }

    setTracing(value: boolean) {
        MainExternalModelInterpreter.main.setTracing(value);
    }

    getTrace(): InterpreterTracer {
        return MainExternalModelInterpreter.main.getTrace();
    }

    evaluate(node: Object): RtObject {
        return this.evaluateWithContext(node, InterpreterContext.EMPTY_CONTEXT);
    }

    evaluateWithContext(node: Object, ctx: InterpreterContext): RtObject {
        MainExternalModelInterpreter.main.reset();
        try {
            return MainExternalModelInterpreter.main.evaluate(node, ctx);
        } catch (e: any) {
            return new RtError(e.message);
        }
    }
}
