// Generated by the Freon Language Generator.
import {
    Agl,
    LanguageIssue,
    LanguageProcessor,
    LanguageProcessorResult,
    ProcessResult,
    SentenceContext,
} from "net.akehurst.language-agl-processor";
import { MetaTyperGrammarStr } from "./FreTyperGrammar.js";
import { FreTyperSyntaxAnalyser } from "./FreTyperSyntaxAnalyser.js";
import { FreMetaLangElement } from '../../languagedef/metalanguage/index.js';
import { TyperDef } from '../metalanguage/index.js';
import { MetaLogger } from '../../utils/no-dependencies/index.js';


const LOGGER = new MetaLogger("FreonTyperReader");

//@ts-ignore
class MyContext implements SentenceContext<FreMetaLangElement> {
    constructor(readonly predefined: Map<string, FreMetaLangElement>) {}
}

/**
 *   Class FreTyperReader is a wrapper for the parser of the typer unit.
 */
export class FreTyperReader {
    analyser: FreTyperSyntaxAnalyser = new FreTyperSyntaxAnalyser();
    res: LanguageProcessorResult<any, any> = Agl.getInstance().processorFromString(
      MetaTyperGrammarStr,
      Agl.getInstance().configuration(undefined, (b) => {
          b.syntaxAnalyserResolverResult(() => this.analyser);
      }),
    );
    // @ts-ignore
    parser: LanguageProcessor<TyperDef, MyContext> = this.res.processor;

    /**
     * Parses and performs a syntax analysis on 'sentence'. If 'sentence' is correct,
     * a model unit will be created,
     * otherwise an error wil be thrown containing the parse or analysis error.
     * @param sentence
     * @param sourceFileName
     */
    readFromString(sentence: string, sourceFileName: string): TyperDef | undefined {
        this.analyser.filename = sourceFileName;
        const startRule: string = "TyperDef";

        // parse the input
        let unit: TyperDef | undefined = undefined;
        if (this.parser) {
            let parseResult: ProcessResult<TyperDef>;
            const options = this.parser.optionsDefault();
            options.parse.goalRuleName = startRule;
            parseResult = this.parser.process(sentence, options);

            const errors = parseResult.issues.errors.asJsReadonlyArrayView();
            if (errors.length > 0) {
                errors.map((err: LanguageIssue) => {
                    // Strip the error message, and add the location information.
                    let location = ` [${sourceFileName}:${err.location? err.location.line: 0}:${err.location? err.location.column : 0}]`;
                    let mess = err.message.replace(/^Failed to match \{.*?} at:\s*\.*\s*/, "Parse error: ");
                    if (!!mess && mess.length > 0) {
                        throw new Error(mess + location);
                    }
                });
            } else {
                unit = parseResult.asm as TyperDef;
            }
            // TODO semantic analysis has been skipped for now, but there are parse errors that are handled in the checker ('checkLimitedRule')
        } else {
          LOGGER.error("NO typer parser!!")
        }
        return unit;
    }
}
