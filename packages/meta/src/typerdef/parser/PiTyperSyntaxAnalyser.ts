// Generated by the ProjectIt Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SyntaxAnalyser = net.akehurst.language.api.syntaxAnalyser.SyntaxAnalyser;
import SharedPackedParseTree = net.akehurst.language.api.sppt.SharedPackedParseTree;
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import SPPTLeaf = net.akehurst.language.api.sppt.SPPTLeaf;
import SPPTNode = net.akehurst.language.api.sppt.SPPTNode;
import { PiTyperDefSyntaxAnalyserPart } from ".";
import { PiElementReference, PiLangElement } from "../../languagedef/metalanguage";
import { PiParseLocation } from "../../utils";

/**
 *   Class MetaTyperSyntaxAnalyser is the main syntax analyser.
 *   The actual work is being done by its parts, one for each model unit,
 *   and one common part that contains the methods used in multiple units.
 *
 */
export class PiTyperSyntaxAnalyser implements SyntaxAnalyser {
    locationMap: any;
    filename: string;
    private _unit_PiTyperDef_analyser: PiTyperDefSyntaxAnalyserPart = new PiTyperDefSyntaxAnalyserPart(this);

    clear(): void {
        throw new Error("Method not implemented.");
    }

    transform<T>(sppt: SharedPackedParseTree): T {
        if (!!sppt.root) {
            return this.transformSharedPackedParseTreeNode(sppt.root) as unknown as T;
        } else {
            return null;
        }
    }

    public transformSharedPackedParseTreeNode(node: SPPTNode): any {
        try {
            if (node.isLeaf) {
                return this.transformSharedPackedParseTreeLeaf(node);
            } else if (node.isBranch) {
                return this.transformSharedPackedParseTreeBranch(node as SPPTBranch);
            }
        } catch (e) {
            if (e.message.startsWith("Syntax error in ") || e.message.startsWith("Error in MetaTyperSyntaxAnalyser")) {
                throw e;
            } else {
                // add more info to the error message
                throw new Error(`Syntax error in "${node?.matchedText.trimEnd()}": ${e.message}`);
            }
        }
    }

    private transformSharedPackedParseTreeLeaf(node: SPPTNode): any {
        let tmp = ((node as SPPTLeaf)?.nonSkipMatchedText).trim();
        if (tmp.length > 0) {
            if (tmp.startsWith('"')) {
                // stringLiteral, strip the surrounding quotes
                tmp = tmp.slice(1, tmp.length - 1);
                return tmp;
            } else if (tmp == "false") {
                // booleanLiteral
                return false;
            } else if (tmp == "true") {
                // booleanLiteral
                return true;
            } else if (Number.isInteger(parseInt(tmp))) {
                // numberLiteral
                return parseInt(tmp);
            } else {
                // identifier
                return tmp;
            }
        }
        return null;
    }

    private transformSharedPackedParseTreeBranch(branch: SPPTBranch): any {
        let brName: string = branch.name;
        if ("PiTyperDef" == brName) {
            return this._unit_PiTyperDef_analyser.transformPiTyperDef(branch);
        } else if ("PitTypeConcept" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitTypeConcept(branch);
        } else if ("PitAnyTypeSpec" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitAnyTypeSpec(branch);
        } else if ("PitInferenceRule" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitInferenceRule(branch);
        } else if ("PitPropertyCallExp" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitPropertyCallExp(branch);
        } else if ("PitSelfExp" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitSelfExp(branch);
        } else if ("PitAnytypeExp" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitAnytypeExp(branch);
        } else if ("PitVarCallExp" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitVarCallExp(branch);
        } else if ("PitCreateExp" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitCreateExp(branch);
        } else if ("PitPropInstance" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitPropInstance(branch);
        } else if ("PitFunctionCallExp" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitFunctionCallExp(branch);
        } else if ("PitLimitedInstanceExp" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitLimitedInstanceExp(branch);
        } else if ("PitWhereExp" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitWhereExp(branch);
        } else if ("PitVarDecl" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitVarDecl(branch);
        } else if ("PitConformanceRule" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitConformanceRule(branch);
        } else if ("PitEqualsRule" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitEqualsRule(branch);
        } else if ("PitLimitedRule" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitLimitedRule(branch);
        } else if ("PitClassifierSpec" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitClassifierSpec(branch);
        } else if ("PitTypeRule" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitTypeRule(branch);
        } else if ("PitExp" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitExp(branch);
        } else if ("__pi_binary_PitExp" == brName) {
            return this._unit_PiTyperDef_analyser.transform__pi_binary_PitExp(branch);
        } else if ("PitProperty" == brName) {
            return this._unit_PiTyperDef_analyser.transformPitProperty(branch);
        } else if ("__pi_reference" == brName) {
            return this.transform__pi_reference(branch);
        } else {
            throw new Error(`Error in PiTyperSyntaxAnalyser: ${brName} not handled for node '${branch?.matchedText}'`);
        }
    }

    /**
     * Generic method to get the children of a branch. Throws an error if no children can be found.
     */
    public getChildren(branch: SPPTBranch): any {
        if (!!branch && !!branch.nonSkipChildren) {
            try {
                return branch.nonSkipChildren.toArray();
            } catch (e) {
                throw new Error(`Cannot follow branch: ${e.message} (${branch.matchedText.trimEnd()})`);
            }
        }
        return null;
    }

    /**
     * Generic method to get the optional group of a branch. Throws an error if no group can be found.
     */
    public getGroup(branch: SPPTBranch) {
        // take the first element in the [0..1] optional group or multi branch
        let group: any = branch;
        let stop: boolean = false;
        while (!stop) {
            let nextOne: any = null;
            try {
                nextOne = group.nonSkipChildren.toArray()[0];
            } catch (e) {
                throw new Error(`Cannot follow group: ${e.message} (${group.matchedText})`);
            }
            if (!nextOne.name.includes("multi") && !nextOne.name.includes("group")) {
                stop = true; // found a branch with actual content, return its parent!
            } else {
                group = nextOne;
            }
        }
        return group;
    }

    public transform__pi_reference(branch: SPPTBranch) {
        if (branch.name.includes("multi") || branch.name.includes("List")) {
            return this.transformSharedPackedParseTreeList<string>(branch, "::::");
        } else {
            return this.transformSharedPackedParseTreeLeaf(branch);
        }
    }

    /**
     * Generic method to transform references
     * ...PiElemRef = identifier;
     */
    public piElemRef<T extends PiLangElement>(branch: SPPTBranch, typeName: string): PiElementReference<T> {
        let referred: string | T = this.transformSharedPackedParseTreeNode(branch);
        if (referred == null || referred == undefined) {
            throw new Error(`Syntax error in "${branch?.parent?.matchedText}": cannot create empty reference`);
        } else if (typeof referred === "string" && (referred as string).length == 0) {
            throw new Error(`Syntax error in "${branch?.parent?.matchedText}": cannot create empty reference`);
        } else {
            return this.makePiElementReferenceWithLocation(referred, typeName, branch);
        }
    }

    private makePiElementReferenceWithLocation<T extends PiLangElement>(referred: string | T, typeName: string, branch: SPPTBranch) {
        const result = PiElementReference.create<T>(referred, typeName);
        const location = PiParseLocation.create({ filename: this.filename, line: branch.location.line, column: branch.location.column });
        result.agl_location = location;
        return result;
    }

    /**
     * Generic method to transform lists
     */
    public transformSharedPackedParseTreeList<T>(branch: SPPTBranch, separator?: string): T[] {
        let result: T[] = [];
        const children = this.getChildren(branch);
        if (!!children) {
            for (const child of children) {
                let element: any = this.transformSharedPackedParseTreeNode(child);
                if (element !== null && element !== undefined) {
                    if (separator == null || separator == undefined) {
                        result.push(element);
                    } else {
                        if (element != separator) {
                            result.push(element);
                        }
                    }
                }
            }
        }
        return result;
    }

    /**
     * Generic method to transform lists of references
     */
    public transformSharedPackedParseTreeRefList<T extends PiLangElement>(
        branch: SPPTBranch,
        typeName: string,
        separator?: string
    ): PiElementReference<T>[] {
        let result: PiElementReference<T>[] = [];
        const children = this.getChildren(branch);
        if (!!children) {
            for (const child of children) {
                let refName: any = this.transformSharedPackedParseTreeNode(child);
                if (refName !== null && refName !== undefined) {
                    if (separator === null || separator === undefined) {
                        result.push(this.makePiElementReferenceWithLocation(refName, typeName, branch));
                    } else {
                        if (refName !== separator) {
                            result.push(this.makePiElementReferenceWithLocation(refName, typeName, branch));
                        }
                    }
                }
            }
        }
        return result;
    }

    public location(branch: net.akehurst.language.api.sppt.SPPTBranch) {
        const location = PiParseLocation.create({
            filename: this.filename,
            line: branch.location.line,
            column: branch.location.column
        });
        return location;
    }
}
