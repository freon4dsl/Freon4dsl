// Generated by the ProjectIt Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by MetaTyperModelUnitReader

export const MetaTyperGrammarStr = `
namespace MetaTyperLanguage
grammar MetaTyperGrammar {
                
// rules for "PiTyperDef"
PiTyperDef = 'typer'
	 ( 'istype' '\{' [ __pi_reference / ',' ]* '}' )?
	 PitTypeConcept*
	 ( 'hastype' '\{' [ __pi_reference / ',' ]* '}' )?
	 PitAnyTypeSpec?
	 PitClassifierSpec* ;

PitTypeConcept = 'type' identifier ( 'base' __pi_reference )?
	 '\{'
	 ( PitProperty ';' )*
	 '}' ;

PitAnyTypeSpec = 'anytype' '\{'
	 PitTypeRule*
	 '}' ;

PitInferenceRule = 'infertype' PitExp ';' ;

PitPropertyCallExp = PitExp '.' __pi_reference ;

PitSelfExp = 'self' ;

PitAnytypeExp = 'anytype' ;

PitVarCallExp = __pi_reference ;

PitCreateExp = __pi_reference '\{' [ PitPropInstance / ',' ]* '}' ;

PitPropInstance = __pi_reference ':' PitExp ;

PitFunctionCallExp = identifier '(' [ PitExp / ',' ]* ')' ;

PitLimitedInstanceExp = ( __pi_reference ':' )?
	 __pi_reference ;

PitWhereExp = PitVarDecl 'where' '\{'
	 ( __pi_binary_PitExp ';' )*
	 '}' ;

PitVarDecl = identifier ':' __pi_reference ;

PitConformanceRule = 'conformsto' PitExp ';' ;

PitEqualsRule = 'equalsto' PitExp ';' ;

PitLimitedRule = PitExp ';' ;

PitClassifierSpec = __pi_reference '\{'
	 PitTypeRule*
	 '}' ;

PitTypeRule = PitInferenceRule 
    | PitConformanceRule 
    | PitEqualsRule 
    | PitLimitedRule  ;

PitExp = PitPropertyCallExp 
    | PitSelfExp 
    | PitAnytypeExp 
    | PitVarCallExp 
    | PitCreateExp 
    | PitLimitedInstanceExp 
    | PitWhereExp 
    | PitFunctionCallExp 
    | __pi_binary_PitExp ;

__pi_binary_PitExp = [PitExp / __pi_binary_operator]2+ ;
leaf __pi_binary_operator = 'conformsto' | 'equalsto' ;

PitProperty = identifier ':' __pi_reference ;

__pi_reference = [ identifier / '::' ]+ ;
        
// white space and comments
skip WHITE_SPACE = "\\s+" ;
skip SINGLE_LINE_COMMENT = "//[^\\r\\n]*" ;
skip MULTI_LINE_COMMENT = "/\\*[^*]*\\*+(?:[^*/][^*]*\\*+)*/" ;
        
// the predefined basic types   
leaf identifier          = "[a-zA-Z_][a-zA-Z0-9_]*" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf stringLiteral       = '"' "[^\\"\\\\]*(\\\\.[^\\"\\\\]*)*" '"' ;
leaf numberLiteral       = "[0-9]+";
leaf booleanLiteral      = 'false' | 'true';
            
}`; // end of grammar
