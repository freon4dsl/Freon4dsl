// Generated by the Freon Language Generator.
import type { KtList, Sentence, SpptDataNodeInfo } from 'net.akehurst.language-agl-processor';

import type {
    FreMetaClassifier,
    FreMetaConcept,
    FreMetaInstance,
    FreMetaLimitedConcept,
    FreMetaProperty,
    MetaElementReference
} from '../../languagedef/metalanguage/index.js';
import type {
    FretBinaryExp,
    FretExp,
    FretTypeRule} from '../metalanguage/index.js';
import {
    FretAnytypeExp,
    FretAnyTypeSpec,
    FretClassifierSpec,
    FretConformanceRule,
    FretConformsExp,
    FretCreateExp,
    FretEqualsExp,
    FretEqualsRule,
    FretFunctionCallExp,
    FretInferenceRule,
    FretLimitedInstanceExp,
    FretLimitedRule,
    FretProperty,
    FretPropertyCallExp,
    FretPropInstance,
    FretSelfExp,
    FretTypeConcept,
    FretVarCallExp,
    FretVarDecl,
    FretWhereExp,
    TyperDef
} from '../metalanguage/index.js';
import type { FreTyperSyntaxAnalyser, ParsedNodeReference} from './FreTyperSyntaxAnalyser.js';
import { PrimValueType } from './FreTyperSyntaxAnalyser.js';


/**
 * This class is the (mainly) generated syntax analyser that reforms the parsed
 * typer definition into instances of our metamodel.
 * The differences are: (1) a parse location is added,
 * (2) the names of FreNodeReferences are adjusted.
 */
export class FreTyperDefSyntaxAnalyserPart {
    mainAnalyser: FreTyperSyntaxAnalyser;

    constructor(mainAnalyser: FreTyperSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * TyperDef = 'typer'
     *	 ( 'istype' '\{' [ __fre_reference / ',' ]* '}' )?
     *	 FretTypeConcept*
     *	 ( 'hastype' '\{' [ __fre_reference / ',' ]* '}' )?
     *	 FretAnyTypeSpec?
     *	 FretClassifierSpec* ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformTyperDef(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): TyperDef {
        // console.log('transformFreTyperDef called: ' + children.toString());
        let __types: MetaElementReference<FreMetaClassifier>[] | undefined = undefined;
        let __typeConcepts: FretTypeConcept[];
        let __conceptsWithType: MetaElementReference<FreMetaClassifier>[] | undefined = undefined;
        let __anyTypeSpec: FretAnyTypeSpec | undefined = undefined;
        let __classifierSpecs: FretClassifierSpec[];
        // RHSOptionalGroup
        if (!!children.asJsReadonlyArrayView()[1]) {
            const _optGroup = children.asJsReadonlyArrayView()[1] as KtList<any>;
            __types = this.mainAnalyser.transformRefList<FreMetaClassifier>(_optGroup.asJsReadonlyArrayView()[2]); // RHSRefListWithSeparator
        }
        // end RHSOptionalGroup
        __typeConcepts = (children.asJsReadonlyArrayView()[2] as KtList<any>).asJsReadonlyArrayView() as FretTypeConcept[]; // RHSPartListEntry
        // RHSOptionalGroup
        if (!!children.asJsReadonlyArrayView()[3]) {
            const _optGroup = children.asJsReadonlyArrayView()[3];

            __conceptsWithType = this.mainAnalyser.transformRefList<FreMetaClassifier>(
              (_optGroup as KtList<any>).asJsReadonlyArrayView()[2]
            ); // RHSRefListWithSeparator
        }
        // end RHSOptionalGroup
        // RHSOptionalGroup
        if (!!children.asJsReadonlyArrayView()[4]) {
            __anyTypeSpec = children.asJsReadonlyArrayView()[4] as FretAnyTypeSpec; // RHSPartEntry
        }
        // end RHSOptionalGroup
        __classifierSpecs = (children.asJsReadonlyArrayView()[5] as KtList<any>).asJsReadonlyArrayView() as FretClassifierSpec[]; // RHSPartListEntry

        return TyperDef.create({
            $types: __types,
            typeConcepts: __typeConcepts,
            $conceptsWithType: __conceptsWithType,
            anyTypeSpec: __anyTypeSpec,
            classifierSpecs: __classifierSpecs,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretTypeConcept = 'type' identifier ( 'base' __fre_reference )?
     *	 '\{'
     *	 ( FretProperty ';' )*
     *	 '}' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretTypeConcept(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretTypeConcept {
        // console.log('transformFretTypeConcept called: ' + children.toString());
        let __name: string;
        let __base: MetaElementReference<FreMetaConcept> | undefined = undefined;
        let __properties: FretProperty[];
        __name = this.mainAnalyser.transformPrimValue<string>(children.asJsReadonlyArrayView()[1].toString(), PrimValueType.identifier); // RHSPrimEntry
        // RHSOptionalGroup
        if (!!children.asJsReadonlyArrayView()[2]) {
            const _optGroup = children.asJsReadonlyArrayView()[2] as KtList<any>;
            __base = this.mainAnalyser.makeMetaElementReference(_optGroup.asJsReadonlyArrayView()[1]);
        }
        // end RHSOptionalGroup
        // RHSPartListWithTerminator
        __properties = [];
        const _myList = (children.asJsReadonlyArrayView()[4] as KtList<any>).asJsReadonlyArrayView();
        _myList.forEach((subNode: KtList<any>) => {
            const _transformed = subNode.asJsReadonlyArrayView()[0];
            if (!!_transformed) {
                __properties.push(_transformed);
            }
        });
        return FretTypeConcept.create({
            name: __name,
            base: __base,
            properties: __properties,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretAnyTypeSpec = 'anytype' '\{'
     *	 FretTypeRule*
     *	 '}' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretAnyTypeSpec(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretAnyTypeSpec {
        // console.log('transformFretAnyTypeSpec called: ' + children.toString());
        let __rules: FretTypeRule[];
        __rules = (children.asJsReadonlyArrayView()[2] as KtList<any>).asJsReadonlyArrayView() as FretTypeRule[]; // RHSPartListEntry

        return FretAnyTypeSpec.create({
            rules: __rules,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretInferenceRule = 'infertype' FretExp ';' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretInferenceRule(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretInferenceRule {
        // console.log('transformFretInferenceRule called: ' + children.toString());
        let __exp: FretExp;
        __exp = children.asJsReadonlyArrayView()[1] as FretExp; // RHSPartEntry

        return FretInferenceRule.create({
            exp: __exp,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretPropertyCallExp = FretExp '.' __fre_reference ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretPropertyCallExp(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretPropertyCallExp {
        // console.log('transformFretPropertyCallExp called: ' + children.toString());
        let __source: FretExp;
        let __property: MetaElementReference<FreMetaProperty>;
        __source = children.asJsReadonlyArrayView()[0] as FretExp; // RHSPartEntry
        __property = this.mainAnalyser.makeMetaElementReference<FreMetaProperty>(children.asJsReadonlyArrayView()[2] as ParsedNodeReference); // RHSRefEntry

        return FretPropertyCallExp.create({
            source: __source,
            $property: __property,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretSelfExp = 'self' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    // @ts-ignore
    public transformFretSelfExp(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretSelfExp {
        // console.log('transformFretSelfExp called: ' + children.toString());

        return FretSelfExp.create({
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretAnytypeExp = 'anytype' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    // @ts-ignore
    public transformFretAnytypeExp(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretAnytypeExp {
        // console.log('transformFretAnytypeExp called: ' + children.toString());

        return FretAnytypeExp.create({
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretVarCallExp = __fre_reference ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretVarCallExp(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretVarCallExp {
        // console.log('transformFretVarCallExp called: ' + children.toString());
        let __variable: MetaElementReference<FretVarDecl>;
        __variable = this.mainAnalyser.makeMetaElementReference<FretVarDecl>(children.asJsReadonlyArrayView()[0] as ParsedNodeReference); // RHSRefEntry

        return FretVarCallExp.create({
            $variable: __variable,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretCreateExp = __fre_reference '\{' [ FretPropInstance / ',' ]* '}' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretCreateExp(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretCreateExp {
        // console.log('transformFretCreateExp called: ' + children.toString());
        let __type: MetaElementReference<FreMetaClassifier>;
        let __propertyDefs: FretPropInstance[];
        __type = this.mainAnalyser.makeMetaElementReference<FreMetaClassifier>(children.asJsReadonlyArrayView()[0] as ParsedNodeReference); // RHSRefEntry
        __propertyDefs = this.mainAnalyser.transformPartList<FretPropInstance>(children.asJsReadonlyArrayView()[2] as KtList<any>, ","); // RHSPartListWithSeparator

        return FretCreateExp.create({
            $type: __type,
            propertyDefs: __propertyDefs,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretPropInstance = __fre_reference ':' FretExp ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretPropInstance(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretPropInstance {
        // console.log('transformFretPropInstance called: ' + children.toString());
        let __property: MetaElementReference<FreMetaProperty>;
        let __value: FretExp;
        __property = this.mainAnalyser.makeMetaElementReference<FreMetaProperty>(children.asJsReadonlyArrayView()[0] as ParsedNodeReference); // RHSRefEntry
        __value = children.asJsReadonlyArrayView()[2] as FretExp; // RHSPartEntry

        return FretPropInstance.create({
            $property: __property,
            value: __value,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretFunctionCallExp = identifier '(' [ FretExp / ',' ]* ')' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretFunctionCallExp(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretFunctionCallExp {
        // console.log('transformFretFunctionCallExp called: ' + children.toString());
        let __calledFunction: string;
        let __arguments: FretExp[];
        __calledFunction = this.mainAnalyser.transformPrimValue<string>(children.asJsReadonlyArrayView()[0].toString(), PrimValueType.identifier); // RHSPrimEntry
        __arguments = this.mainAnalyser.transformPartList<FretExp>(children.asJsReadonlyArrayView()[2] as KtList<any>, ","); // RHSPartListWithSeparator

        return FretFunctionCallExp.create({
            calledFunction: __calledFunction,
            actualParameters: __arguments,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretLimitedInstanceExp = ( '#' __fre_reference ':' )?
     *	 __fre_reference ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretLimitedInstanceExp(
      nodeInfo: SpptDataNodeInfo,
      children: KtList<object>,
      sentence: Sentence,
    ): FretLimitedInstanceExp {
        // console.log('transformFretLimitedInstanceExp called: ' + children.toString());
        let __myLimited: MetaElementReference<FreMetaLimitedConcept> | undefined = undefined;
        let __myInstance: MetaElementReference<FreMetaInstance>;
        // RHSOptionalGroup
        if (!!children.asJsReadonlyArrayView()[0]) {
            const _optGroup = children.asJsReadonlyArrayView()[0] as KtList<any>;
            __myLimited = this.mainAnalyser.makeMetaElementReference<FreMetaLimitedConcept>(_optGroup.asJsReadonlyArrayView()[1]); // RHSRefEntry
        }
        // end RHSOptionalGroup
        __myInstance = this.mainAnalyser.makeMetaElementReference<FreMetaInstance>(children.asJsReadonlyArrayView()[1] as ParsedNodeReference); // RHSRefEntry
        return FretLimitedInstanceExp.create({
            $myLimited: __myLimited,
            $myInstance: __myInstance,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretWhereExp = FretVarDecl 'where' '\{'
     *	 ( __fre_binary_FretExp ';' )*
     *	 '}' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretWhereExp(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretWhereExp {
        // console.log('transformFretWhereExp called: ' + children.toString());
        let __variable: FretVarDecl;
        let __conditions: FretBinaryExp[];
        __variable = children.asJsReadonlyArrayView()[0] as FretVarDecl; // RHSPartEntry
        // RHSBinExpListWithTerminator
        __conditions = [];
        children
          .asJsReadonlyArrayView()[3]
          // @ts-ignore
          .toArray()
          .forEach((subNode: KtList<any>) => {
              const _transformed: FretBinaryExp = subNode.asJsReadonlyArrayView()[0];
              if (!!_transformed) {
                  __conditions.push(_transformed);
              }
          }); // end RHSBinExpListWithTerminator
        return FretWhereExp.create({
            variable: __variable,
            conditions: __conditions,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretVarDecl = identifier ':' __fre_reference ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretVarDecl(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretVarDecl {
        // console.log('transformFretVarDecl called: ' + children.toString());
        let __name: string;
        let __type: MetaElementReference<FreMetaClassifier>;
        __name = this.mainAnalyser.transformPrimValue<string>(children.asJsReadonlyArrayView()[0].toString(), PrimValueType.identifier); // RHSPrimEntry
        __type = this.mainAnalyser.makeMetaElementReference<FreMetaClassifier>(children.asJsReadonlyArrayView()[2] as ParsedNodeReference); // RHSRefEntry

        return FretVarDecl.create({
            name: __name,
            $type: __type,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretConformanceRule = 'conformsto' FretExp ';' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretConformanceRule(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretConformanceRule {
        // console.log('transformFretConformanceRule called: ' + children.toString());
        let __exp: FretExp;
        __exp = children.asJsReadonlyArrayView()[1] as FretExp; // RHSPartEntry

        return FretConformanceRule.create({
            exp: __exp,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretEqualsRule = 'equalsto' FretExp ';' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretEqualsRule(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretEqualsRule {
        // console.log('transformFretEqualsRule called: ' + children.toString());
        let __exp: FretExp;
        __exp = children.asJsReadonlyArrayView()[1] as FretExp; // RHSPartEntry

        return FretEqualsRule.create({
            exp: __exp,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretLimitedRule = FretExp ';' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretLimitedRule(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretLimitedRule {
        // console.log('transformFretLimitedRule called: ' + children.toString());
        let __exp: FretExp;
        __exp = children.asJsReadonlyArrayView()[0] as FretExp; // RHSPartEntry

        return FretLimitedRule.create({
            exp: __exp,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretClassifierSpec = __fre_reference '\{'
     *	 FretTypeRule*
     *	 '}' ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretClassifierSpec(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretClassifierSpec {
        // console.log('transformFretClassifierSpec called: ' + children.toString());
        let __myClassifier: MetaElementReference<FreMetaClassifier>;
        let __rules: FretTypeRule[];
        __myClassifier = this.mainAnalyser.makeMetaElementReference<FreMetaClassifier>(children.asJsReadonlyArrayView()[0] as ParsedNodeReference); // RHSRefEntry
        __rules = (children.asJsReadonlyArrayView()[2] as KtList<any>).asJsReadonlyArrayView() as FretTypeRule[]; // RHSPartListEntry

        return FretClassifierSpec.create({
            $myClassifier: __myClassifier,
            rules: __rules,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretProperty = identifier ':' __fre_reference ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transformFretProperty(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretProperty {
        // console.log('transformFretProperty called: ' + children.toString());
        let __name: string;
        let __type: MetaElementReference<FreMetaClassifier>;
        __name = this.mainAnalyser.transformPrimValue<string>(children.asJsReadonlyArrayView()[0].toString(), PrimValueType.identifier); // RHSPrimEntry
        __type = this.mainAnalyser.makeMetaElementReference<FreMetaClassifier>(children.asJsReadonlyArrayView()[2] as ParsedNodeReference); // RHSRefEntry

        return FretProperty.create({
            name: __name,
            typeReference: __type,
            aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretTypeRule = FretInferenceRule
     *    | FretConformanceRule
     *    | FretEqualsRule
     *    | FretLimitedRule  ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    // @ts-ignore
    public transformFretTypeRule(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretTypeRule {
        // console.log('transformFretTypeRule called: ' + children.toString());
        return children.asJsReadonlyArrayView()[0] as FretTypeRule;
    }

    /**
     * Method to transform branches that match the following rule:
     * FretExp = FretPropertyCallExp
     *    | FretSelfExp
     *    | FretAnytypeExp
     *    | FretVarCallExp
     *    | FretCreateExp
     *    | FretLimitedInstanceExp
     *    | FretWhereExp
     *    | FretFunctionCallExp
     *    | __fre_binary_FretExp ;
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    // @ts-ignore
    public transformFretExp(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretExp {
        // console.log('transformFretExp called: ' + children.toString());
        return children.asJsReadonlyArrayView()[0] as FretExp;
    }

    /**
     * Generic method to transform binary expressions, which are parsed
     * according to these rules:
     * __fre_binary_FretExp = [FretExp / __fre_binary_operator]2+ ;
     * leaf __fre_binary_operator = 'conformsto' | 'equalsto' ;
     *
     * In this method we build a crooked tree, which in a later phase needs to be balanced
     * according to the priorities of the operators.
     *
     * @param nodeInfo
     * @param children
     * @param sentence
     */
    public transform__fre_binary_FretExp(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): FretExp | undefined {
        // console.log('transform__fre_binary_FretExp called: ' + children.toString());
        let index = 0;
        let list = children.asJsReadonlyArrayView();
        let first: FretExp | undefined = list[index++] as FretExp;
        while (index < list.length) {
            let operator: string = list[index++].toString();
            let second: FretExp = list[index++] as FretExp;
            let combined: FretExp | undefined = undefined;
            switch (operator) {
                case "equalsto": {
                    combined = FretEqualsExp.create({
                        left: first,
                        right: second,
                        aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
                    });
                    break;
                }
                case "conformsto": {
                    combined = FretConformsExp.create({
                        left: first,
                        right: second,
                        aglParseLocation: this.mainAnalyser.location(sentence, nodeInfo.node),
                    });
                    break;
                }
                default: {
                    combined = undefined;
                }
            }
            first = combined;
        }
        return first;
    }
}
