// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import {
    MetaElementReference,
    FreClassifier,
    FreLimitedConcept,
    FreInstance, FreProperty, FreConcept
} from "../../languagedef/metalanguage";
import {
    TyperDef,
    FretAnyTypeSpec,
    FretPropertyCallExp,
    FretSelfExp,
    FretAnytypeExp,
    FretLimitedInstanceExp,
    FretWhereExp,
    FretFunctionCallExp,
    FretInferenceRule,
    FretLimitedRule,
    FretExp,
    FretProperty,
    FretEqualsExp,
    FretConformsExp
} from "../metalanguage";
import { FreTyperSyntaxAnalyser } from "./FreTyperSyntaxAnalyser";
import { FretTypeConcept } from "../metalanguage/FretTypeConcept";
import { FretClassifierSpec } from "../metalanguage/FretClassifierSpec";
import { FretTypeRule } from "../metalanguage/FretTypeRule";
import { FretVarCallExp } from "../metalanguage/expressions/FretVarCallExp";
import { FretVarDecl } from "../metalanguage/FretVarDecl";
import { FretCreateExp } from "../metalanguage/expressions/FretCreateExp";
import { FretPropInstance } from "../metalanguage/FretPropInstance";
import { FretBinaryExp } from "../metalanguage/expressions/FretBinaryExp";
import { FretConformanceRule } from "../metalanguage/FretConformanceRule";
import { FretEqualsRule } from "../metalanguage/FretEqualsRule";

/**
 * This class is the (mainly) generated syntax analyser that reforms the parsed
 * typer definition into instances of our metamodel.
 * The differences are: (1) a parse location is added,
 * (2) the names of FreElementReferences are adjusted.
 */
export class FreTyperDefSyntaxAnalyserPart {
    mainAnalyser: FreTyperSyntaxAnalyser;

    constructor(mainAnalyser: FreTyperSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * TyperDef = 'typer'
     *	 ( 'istype' '\{' [ __fre_reference / ',' ]* '}' )?
     *	 FretTypeConcept*
     *	 ( 'hastype' '\{' [ __fre_reference / ',' ]* '}' )?
     *	 FretAnyTypeSpec?
     *	 FretClassifierSpec* ;
     * @param branch
     * @private
     */
    public transformTyperDef(branch: SPPTBranch): TyperDef {
        // console.log('transformTyperDef called: ' + branch.name);
        let __types: MetaElementReference<FreClassifier>[];
        let __typeConcepts: FretTypeConcept[];
        let __conceptsWithType: MetaElementReference<FreClassifier>[];
        let __anyTypeSpec: FretAnyTypeSpec;
        let __classifierSpecs: FretClassifierSpec[];
        const children = this.mainAnalyser.getChildren(branch);
        if (!children[1].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[1]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);

            __types = this.mainAnalyser.transformSharedPackedParseTreeRefList<FreClassifier>(_propItem[2], "FreClassifier", ","); // RHSRefListWithSeparator
        } // RHSPartListEntry
        if (children[2].name !== "FretTypeConcept") {
            __typeConcepts = this.mainAnalyser.transformSharedPackedParseTreeList<FretTypeConcept>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __typeConcepts = [];
            for (const child of children) {
                __typeConcepts.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        if (!children[3].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[3]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);

            __conceptsWithType = this.mainAnalyser.transformSharedPackedParseTreeRefList<FreClassifier>(_propItem[2], "FreClassifier", ","); // RHSRefListWithSeparator
        }
        if (!children[4].isEmptyMatch) {
            // RHSOptionalGroup
            const _optBranch = this.mainAnalyser.getChildren(children[4]);
            __anyTypeSpec = this.mainAnalyser.transformSharedPackedParseTreeNode(_optBranch[0]); // RHSPartEntry
        } // RHSPartListEntry
        if (children[5].name !== "FretClassifierSpec") {
            __classifierSpecs = this.mainAnalyser.transformSharedPackedParseTreeList<FretClassifierSpec>(children[5]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __classifierSpecs = [];
            for (const child of children) {
                __classifierSpecs.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        
        return TyperDef.create({
            __types: __types,
            typeConcepts: __typeConcepts,
            __conceptsWithType: __conceptsWithType,
            anyTypeSpec: __anyTypeSpec,
            classifierSpecs: __classifierSpecs,
            agl_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretTypeConcept = 'type' identifier ( 'base' __fre_reference )?
     *	 '\{'
     *	 ( FretProperty ';' )*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformFretTypeConcept(branch: SPPTBranch): FretTypeConcept {
        // console.log('transformFretTypeConcept called: ' + branch.name);
        let __name: string;
        let __base: MetaElementReference<FreConcept>;
        let __properties: FretProperty[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry

        if (!children[2].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[2]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __base = this.mainAnalyser.freNodeRef<FreConcept>(_propItem[1], "FreConcept"); // RHSRefEntry
        } // RHSListGroup
        __properties = [];
        const _myList = this.mainAnalyser.getChildren(children[4]);
        _myList.forEach(subNode => {
            const _transformed = this.mainAnalyser.transformSharedPackedParseTreeNode(subNode.nonSkipChildren?.toArray()[0]);
            if (!!_transformed) {
                __properties.push(_transformed);
            }
        });
        return FretTypeConcept.create({ name: __name, base: __base, properties: __properties, agl_location: this.mainAnalyser.location(branch) });
    }



    /**
     * Method to transform branches that match the following rule:
     * FretAnyTypeSpec = 'anytype' '\{'
     *	 FretTypeRule*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformFretAnyTypeSpec(branch: SPPTBranch): FretAnyTypeSpec {
        // console.log('transformFretAnyTypeSpec called: ' + branch.name);
        let __rules: FretTypeRule[];
        const children = this.mainAnalyser.getChildren(branch); // RHSPartListEntry
        if (children[2].name !== "FretTypeRule") {
            __rules = this.mainAnalyser.transformSharedPackedParseTreeList<FretTypeRule>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __rules = [];
            for (const child of children) {
                __rules.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return FretAnyTypeSpec.create({ rules: __rules, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretInferenceRule = 'infertype' FretExp ';' ;
     * @param branch
     * @private
     */
    public transformFretInferenceRule(branch: SPPTBranch): FretInferenceRule {
        // console.log('transformFretInferenceRule called: ' + branch.name);
        let __exp: FretExp;
        const children = this.mainAnalyser.getChildren(branch);
        __exp = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPartEntry
        return FretInferenceRule.create({ exp: __exp, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretPropertyCallExp = FretExp '.' __fre_reference ;
     * @param branch
     * @private
     */
    public transformFretPropertyCallExp(branch: SPPTBranch): FretPropertyCallExp {
        // console.log('transformFretPropertyCallExp called: ' + branch.name);
        let __source: FretExp;
        let __property: MetaElementReference<FreProperty>;
        const children = this.mainAnalyser.getChildren(branch);
        __source = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPartEntry
        __property = this.mainAnalyser.freNodeRef<FreProperty>(children[2], "FreProperty"); // RHSRefEntry
        return FretPropertyCallExp.create({ source: __source, __property: __property, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretSelfExp = 'self' ;
     * @param branch
     * @private
     */
    public transformFretSelfExp(branch: SPPTBranch): FretSelfExp {
        // console.log('transformFretSelfExp called: ' + branch.name);

        const children = this.mainAnalyser.getChildren(branch);
        return FretSelfExp.create({ agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretAnytypeExp = 'anytype' ;
     * @param branch
     * @private
     */
    public transformFretAnytypeExp(branch: SPPTBranch): FretAnytypeExp {
        // console.log('transformFretAnytypeExp called: ' + branch.name);

        const children = this.mainAnalyser.getChildren(branch);
        return FretAnytypeExp.create({ agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretVarCallExp = __fre_reference ;
     * @param branch
     * @private
     */
    public transformFretVarCallExp(branch: SPPTBranch): FretVarCallExp {
        // console.log('transformFretVarCallExp called: ' + branch.name);
        let __variable: MetaElementReference<FretVarDecl>;
        const children = this.mainAnalyser.getChildren(branch);
        __variable = this.mainAnalyser.freNodeRef<FretVarDecl>(children[0], "FretVarDecl"); // RHSRefEntry
        return FretVarCallExp.create({ __variable: __variable, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretCreateExp = __fre_reference '\{' [ FretPropInstance / ',' ]* '}' ;
     * @param branch
     * @private
     */
    public transformFretCreateExp(branch: SPPTBranch): FretCreateExp {
        // console.log('transformFretCreateExp called: ' + branch.name);
        let __type: MetaElementReference<FreClassifier>;
        let __propertyDefs: FretPropInstance[];
        const children = this.mainAnalyser.getChildren(branch);
        __type = this.mainAnalyser.freNodeRef<FreClassifier>(children[0], "FreClassifier"); // RHSRefEntry
        __propertyDefs = this.mainAnalyser.transformSharedPackedParseTreeList<FretPropInstance>(children[2], ","); // RHSPartListWithSeparator
        return FretCreateExp.create({ __type: __type, propertyDefs: __propertyDefs, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretPropInstance = __fre_reference ':' FretExp ;
     * @param branch
     * @private
     */
    public transformFretPropInstance(branch: SPPTBranch): FretPropInstance {
        // console.log('transformFretPropInstance called: ' + branch.name);
        let __property: MetaElementReference<FreProperty>;
        let __value: FretExp;
        const children = this.mainAnalyser.getChildren(branch);
        __property = this.mainAnalyser.freNodeRef<FreProperty>(children[0], "FreProperty"); // RHSRefEntry
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[2]); // RHSPartEntry
        return FretPropInstance.create({ __property: __property, value: __value, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretFunctionCallExp = identifier '(' [ FretExp / ',' ]* ')' ;
     * @param branch
     * @private
     */
    public transformFretFunctionCallExp(branch: SPPTBranch): FretFunctionCallExp {
        // console.log('transformFretFunctionCallExp called: ' + branch.name);
        let __calledFunction: string;
        let __arguments: FretExp[];
        const children = this.mainAnalyser.getChildren(branch);
        __calledFunction = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry
        __arguments = this.mainAnalyser.transformSharedPackedParseTreeList<FretExp>(children[2], ","); // RHSPartListWithSeparator
        return FretFunctionCallExp.create({ calledFunction: __calledFunction, actualParameters: __arguments, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretLimitedInstanceExp = ( __fre_reference ':' )?
     *	 __fre_reference ;
     * @param branch
     * @private
     */
    public transformFretLimitedInstanceExp(branch: SPPTBranch): FretLimitedInstanceExp {
        // console.log('transformFretLimitedInstanceExp called: ' + branch.name);
        let __myLimited: MetaElementReference<FreLimitedConcept>;
        let __myInstance: MetaElementReference<FreInstance>;
        const children = this.mainAnalyser.getChildren(branch);
        if (!children[0].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[0]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __myLimited = this.mainAnalyser.freNodeRef<FreLimitedConcept>(_propItem[0], "FreLimitedConcept"); // RHSRefEntry
        }
        __myInstance = this.mainAnalyser.freNodeRef<FreInstance>(children[1], "FreInstance"); // RHSRefEntry
        return FretLimitedInstanceExp.create({ __myLimited: __myLimited, __myInstance: __myInstance, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretWhereExp = FretVarDecl 'where' '\{'
     *	 ( __fre_binary_FretExp ';' )*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformFretWhereExp(branch: SPPTBranch): FretWhereExp {
        // console.log('transformFretWhereExp called: ' + branch.name);
        let __variable: FretVarDecl;
        let __conditions: FretBinaryExp[];
        const children = this.mainAnalyser.getChildren(branch);
        __variable = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPartEntry
        // RHSBinExpListWithTerminator
        __conditions = [];
        const _myList = this.mainAnalyser.getChildren(children[3]);
        _myList.forEach(subNode => {
            const _transformed = this.mainAnalyser.transformSharedPackedParseTreeNode(subNode.nonSkipChildren?.toArray()[0]);
            if (!!_transformed) {
                __conditions.push(_transformed);
            }
        });
        return FretWhereExp.create({ variable: __variable, conditions: __conditions, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretVarDecl = identifier ':' __fre_reference ;
     * @param branch
     * @private
     */
    public transformFretVarDecl(branch: SPPTBranch): FretVarDecl {
        // console.log('transformFretVarDecl called: ' + branch.name);
        let __name: string;
        let __type: MetaElementReference<FreClassifier>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry
        __type = this.mainAnalyser.freNodeRef<FreClassifier>(children[2], "FreClassifier"); // RHSRefEntry
        return FretVarDecl.create({ name: __name, __type: __type, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretConformanceRule = 'conformsto' FretExp ';' ;
     * @param branch
     * @private
     */
    public transformFretConformanceRule(branch: SPPTBranch): FretConformanceRule {
        // console.log('transformFretConformanceRule called: ' + branch.name);
        let __exp: FretExp;
        const children = this.mainAnalyser.getChildren(branch);
        __exp = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPartEntry
        return FretConformanceRule.create({ exp: __exp, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretEqualsRule = 'equalsto' FretExp ';' ;
     * @param branch
     * @private
     */
    public transformFretEqualsRule(branch: SPPTBranch): FretEqualsRule {
        // console.log('transformFretEqualsRule called: ' + branch.name);
        let __exp: FretExp;
        const children = this.mainAnalyser.getChildren(branch);
        __exp = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPartEntry
        return FretEqualsRule.create({ exp: __exp, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretLimitedRule = FretExp ';' ;
     * @param branch
     * @private
     */
    public transformFretLimitedRule(branch: SPPTBranch): FretLimitedRule {
        // console.log('transformFretLimitedRule called: ' + branch.name);
        let __exp: FretExp;
        const children = this.mainAnalyser.getChildren(branch);
        __exp = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPartEntry
        return FretLimitedRule.create({ exp: __exp, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretClassifierSpec = __fre_reference '\{'
     *	 FretTypeRule*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformFretClassifierSpec(branch: SPPTBranch): FretClassifierSpec {
        // console.log('transformFretClassifierSpec called: ' + branch.name);
        let __myClassifier: MetaElementReference<FreClassifier>;
        let __rules: FretTypeRule[];
        const children = this.mainAnalyser.getChildren(branch);
        __myClassifier = this.mainAnalyser.freNodeRef<FreClassifier>(children[0], "FreClassifier"); // RHSRefEntry
        // RHSPartListEntry
        if (children[2].name !== "FretTypeRule") {
            __rules = this.mainAnalyser.transformSharedPackedParseTreeList<FretTypeRule>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __rules = [];
            for (const child of children) {
                __rules.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return FretClassifierSpec.create({ __myClassifier: __myClassifier, rules: __rules, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretProperty = identifier ':' __fre_reference ;
     * @param branch
     * @private
     */
    public transformFretProperty(branch: SPPTBranch): FretProperty {
        // console.log('transformFretProperty called: ' + branch.name);
        let __name: string;
        let __type: MetaElementReference<FreClassifier>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry
        __type = this.mainAnalyser.freNodeRef<FreClassifier>(children[2], "FreClassifier"); // RHSRefEntry
        return FretProperty.create({ name: __name, typeReference: __type, agl_location: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretTypeRule = FretInferenceRule
     *    | FretConformanceRule
     *    | FretEqualsRule
     *    | FretLimitedRule  ;
     * @param branch
     * @private
     */
    public transformFretTypeRule(branch: SPPTBranch): FretTypeRule {
        // console.log('transformFretTypeRule called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * FretExp = FretPropertyCallExp
     *    | FretSelfExp
     *    | FretAnytypeExp
     *    | FretVarCallExp
     *    | FretCreateExp
     *    | FretLimitedInstanceExp
     *    | FretWhereExp
     *    | FretFunctionCallExp
     *    | __fre_binary_FretExp ;
     * @param branch
     * @private
     */
    public transformFretExp(branch: SPPTBranch): FretExp {
        // console.log('transformFretExp called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Generic method to transform binary expressions, which are parsed
     * according to these rules:
     * __fre_binary_FretExp = [FretExp / __fre_binary_operator]2+ ;
     * leaf __fre_binary_operator = 'conformsto' | 'equalsto' ;
     *
     * In this method we build a crooked tree, which in a later phase needs to be balanced
     * according to the priorities of the operators.
     * @param branch
     * @private
     */
    public transform__fre_binary_FretExp(branch: SPPTBranch): FretExp {
        // console.log('transform__fre_binary_FretExp called: ' + branch.name);
        const children = branch.nonSkipChildren.toArray();
        let index = 0;
        let first = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
        while (index < children.length) {
            let operator = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
            let second = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
            let combined: FretExp = null;
            
            switch (operator) {
                case "equalsto": {
                    combined = FretEqualsExp.create({ left: first, right: second, agl_location: this.mainAnalyser.location(branch) });
                    break;
                }
                case "conformsto": {
                    combined = FretConformsExp.create({ left: first, right: second, agl_location: this.mainAnalyser.location(branch) });
                    break;
                }
                default: {
                    combined = null;
                }
            }
            first = combined;
        }
        return first;
    }
}
