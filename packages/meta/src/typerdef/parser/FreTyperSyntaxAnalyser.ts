// Generated by the Freon Language Generator.
import type {
    KtList,
    Sentence,
    SpptDataNodeInfo} from "net.akehurst.language-agl-processor";
import {
    SyntaxAnalyserByMethodRegistrationAbstract
} from "net.akehurst.language-agl-processor";
import type { SPPTBranch, SpptDataNode } from "net.akehurst.language-agl-processor";
import { FreTyperDefSyntaxAnalyserPart } from "./index.js";
import type { TyperDef } from '../metalanguage/index.js';
import { FreMetaLangElement, MetaElementReference } from '../../languagedef/metalanguage/index.js';
import { FreParseLocation } from '../../utils/no-dependencies/index.js';

export enum PrimValueType {
    "string",
    "identifier",
    "boolean",
    "number",
}

export class ParsedNodeReference extends FreMetaLangElement {
    pathname: string[];

    constructor(pathname: string[], location: FreParseLocation) {
        super();
        this.pathname = pathname;
        this.aglParseLocation = location;
    }

    toString() {
        return `[ParsedNodeReference: ${this.pathname} ${this.aglParseLocation.line}]`;
    }
}

/**
 *   Class MetaTyperSyntaxAnalyser is the main syntax analyser.
 *   The actual work is being done by its parts, one for each model unit,
 *   and one common part that contains the methods used in multiple units.
 *
 */
export class FreTyperSyntaxAnalyser extends SyntaxAnalyserByMethodRegistrationAbstract<TyperDef> {
    filename: string = "";
    private _unit_TyperDef_analyser: FreTyperDefSyntaxAnalyserPart = new FreTyperDefSyntaxAnalyserPart(this);

    // @ts-ignore
    registerHandlers(branch: SPPTBranch) {
        super.registerFor("TyperDef", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformTyperDef(n, c, s));
        super.registerFor("FretAnyTypeSpec", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretAnyTypeSpec(n, c, s));
        super.registerFor("FretInferenceRule", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretInferenceRule(n, c, s));
        super.registerFor("FretPropertyCallExp", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretPropertyCallExp(n, c, s));
        super.registerFor("FretSelfExp", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretSelfExp(n, c, s));
        super.registerFor("FretAnytypeExp", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretAnytypeExp(n, c, s));
        super.registerFor("FretVarCallExp", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretVarCallExp(n, c, s));
        super.registerFor("FretCreateExp", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretCreateExp(n, c, s));
        super.registerFor("FretPropInstance", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretPropInstance(n, c, s));
        super.registerFor("FretFunctionCallExp", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretFunctionCallExp(n, c, s));
        super.registerFor("FretLimitedInstanceExp", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretLimitedInstanceExp(n, c, s));
        super.registerFor("FretWhereExp", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretWhereExp(n, c, s));
        super.registerFor("FretVarDecl", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretVarDecl(n, c, s));
        super.registerFor("FretConformanceRule", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretConformanceRule(n, c, s));
        super.registerFor("FretEqualsRule", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretEqualsRule(n, c, s));
        super.registerFor("FretLimitedRule", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretLimitedRule(n, c, s));
        super.registerFor("FretClassifierSpec", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretClassifierSpec(n, c, s));
        super.registerFor("FretTypeRule", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretTypeRule(n, c, s));
        super.registerFor("FretExp", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretExp(n, c, s));
        super.registerFor("__fre_binary_FretExp", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transform__fre_binary_FretExp(n, c, s));
        super.registerFor("FretProperty", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretProperty(n, c, s));
        super.registerFor("FretTypeConcept", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this._unit_TyperDef_analyser.transformFretTypeConcept(n, c, s));
        super.registerFor("__fre_reference", (n: SpptDataNodeInfo, c: KtList<object>, s: Sentence) => this.transform__fre_reference(n, c, s));
    }

    /**
     * Generic method to transform lists of primitive values
     */
    public transformPrimList<T extends string | number | boolean>(list: string[], primType: PrimValueType, separator?: string): T[] {
        // console.log("transformPrimList called: "  + JSON.stringify(list));
        let result: T[] = [];
        if (!!list) {
            list.forEach((element) => {
                if (element !== null && element !== undefined && element !== separator) {
                    result.push(this.transformPrimValue(element, primType) as T);
                }
            });
        }
        return result;
    }

    /**
     * Generic method to transform a primitive value, which is parsed as a string, into the correct type.
     */
    public transformPrimValue<T extends string | number | boolean>(element: string, primType: PrimValueType): T {
        // console.log("transformPrimValue called: " + element + ", " + primType);
        switch (primType) {
            case PrimValueType.number:
                const num = parseFloat(element);
                return (isNaN(num) ? 0 : num) as T; // Handle invalid number gracefully.
            case PrimValueType.string:
            case PrimValueType.identifier:
                // todo make sure we remove only the outer quotes
                return element.replace(/"/g, "") as T;
            case PrimValueType.boolean:
                return (element.toLowerCase() === "true") as T; // Case-insensitive matching for booleans.
            default:
                return element as T; // Default case (string)
        }
    }

    /**
     * Generic method to transform lists of parts.
     */
    public transformPartList<T>(list: KtList<T>, separator?: string): T[] {
        // console.log("transformPartList called: " + JSON.stringify(list));
        let result: T[] = [];
        if (!!list) {
            for (const element of list.asJsReadonlyArrayView()) {
                if (element !== null && element !== undefined && element !== separator) {
                    result.push(element);
                }
            }
        }
        return result;
    }

    /**
     * Generic method to transform lists of references. The input will be a list of ParsedNodeReferences, which
     * result from transform__fre_reference. However, the input may also contain objects of type String,
     * which hold the separator between the elements of the reference list, not the 'reference separator' ("::").
     */
    public transformRefList<T extends FreMetaLangElement>(list: KtList<T>): MetaElementReference<T>[] {
        // console.log("transformRefList called: " + JSON.stringify(list));
        let result: MetaElementReference<T>[] = [];
        if (!!list) {
            for (const child of list.asJsReadonlyArrayView()) {
                if (child.constructor.name === 'ParsedNodeReference') {
                    result.push(this.makeMetaElementReference<T>(child as unknown as ParsedNodeReference));
                }
            }
        }
        return result;
    }

    /**
     * Generic method to transform a single reference into a temporary object.
     * The actual MetaElementReference object is created when the type of the referred node is known.
     * The 'reference separator' ("::") is removed in the process.
     */
    public transform__fre_reference(nodeInfo: SpptDataNodeInfo, children: KtList<object>, sentence: Sentence): ParsedNodeReference {
        // console.log("transform__fre_reference called: " + JSON.stringify(children));
        let pathname: string[] = [];
        for (const child of children.asJsReadonlyArrayView()) {
            if (child !== null && child !== undefined && child.toString() !== "::") {
                pathname.push(child.toString());
            }
        }
        return new ParsedNodeReference(pathname, this.location(sentence, nodeInfo.node));
    }

    /**
     * This method is a shortcut. It needs to be removed when Freon is changed to handle multiple languages.
     *
     * Explanation:
     * The code in this file and most of the code in this folder are generated from the project samples/FreLanguage.
     * In this project FreNodeReference is used, as well as the generated scoper, which depends on the FreBaseScoper in core.
     * In this package, however, we use FreMetaElementReference and a simplified scoper (FretScoper and FreLangScoper from
     * src/languagedef/metalanguage). These have not yet been adjusted to handle path names. Instead, they use one string as name.
     * At the moment this is enough, there are no path names in the definition files.
     *
     * Therefore, instead of changing the scopers and the FreMetaElementReference class, this method transforms the array
     * of strings of a ParsedNodeReference into a FreMetaElementReference, using only the first element (because in this case
     * there is only one element in the array).
     *
     * @param referred
     * @private
     */
    public makeMetaElementReference<T extends FreMetaLangElement>(referred: ParsedNodeReference) {
        let name: string | T;
        if (Array.isArray(referred.pathname)) {
            name = referred.pathname[0];
        } else {
            name = referred.pathname;
        }
        const result = MetaElementReference.create<T>(name);
        result.aglParseLocation = (referred as ParsedNodeReference).aglParseLocation;
        return result;
    }

    /**
     * Generic method to transform location information
     */
    public location(sentence: Sentence, node: SpptDataNode): FreParseLocation {
        const location = sentence.locationFor(node.startPosition, node.nextInputNoSkip - node.startPosition);
        return FreParseLocation.create({
            filename: this.filename,
            line: location.line,
            column: location.column,
        });
    }
}
