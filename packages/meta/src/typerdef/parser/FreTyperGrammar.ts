// Generated by the Freon Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by MetaTyperModelUnitReader

export const MetaTyperGrammarStr = `
namespace MetaTyperLanguage
grammar MetaTyperGrammar {

// rules for "TyperDef"
TyperDef = 'typer'
	 ( 'istype' '\{' [ __fre_reference / ',' ]* '}' )?
	 FretTypeConcept*
	 ( 'hastype' '\{' [ __fre_reference / ',' ]* '}' )?
	 FretAnyTypeSpec?
	 FretClassifierSpec* ;

FretTypeConcept = 'type' identifier ( 'base' __fre_reference )?
	 '\{'
	 ( FretProperty ';' )*
	 '}' ;

FretAnyTypeSpec = 'anytype' '\{'
	 FretTypeRule*
	 '}' ;

FretInferenceRule = 'infertype' FretExp ';' ;

FretPropertyCallExp = FretExp '.' __fre_reference ;

FretSelfExp = 'self' ;

FretAnytypeExp = 'anytype' ;

FretVarCallExp = __fre_reference ;

FretCreateExp = __fre_reference '\{' [ FretPropInstance / ',' ]* '}' ;

FretPropInstance = __fre_reference ':' FretExp ;

FretFunctionCallExp = identifier '(' [ FretExp / ',' ]* ')' ;

FretLimitedInstanceExp = ( '#' __fre_reference ':' )?
	 __fre_reference ;

FretWhereExp = FretVarDecl 'where' '\{'
	 ( __fre_binary_FretExp ';' )*
	 '}' ;

FretVarDecl = identifier ':' __fre_reference ;

FretConformanceRule = 'conformsto' FretExp ';' ;

FretEqualsRule = 'equalsto' FretExp ';' ;

FretLimitedRule = FretExp ';' ;

FretClassifierSpec = __fre_reference '\{'
	 FretTypeRule*
	 '}' ;

FretTypeRule = FretInferenceRule
    | FretConformanceRule
    | FretEqualsRule
    | FretLimitedRule  ;

FretExp = FretPropertyCallExp
  | FretLimitedInstanceExp
  | FretFunctionCallExp
  | FretVarCallExp
  | FretSelfExp
  | FretAnytypeExp
  | FretCreateExp
  | FretWhereExp
  | __fre_binary_FretExp ;

__fre_binary_FretExp = [FretExp / __fre_binary_operator]2+ ;
leaf __fre_binary_operator = 'conformsto' | 'equalsto' ;

FretProperty = identifier ':' __fre_reference ;

__fre_reference = [ identifier / '::' ]+ ;

// white space and comments
skip WHITE_SPACE = "\\s+" ;
skip SINGLE_LINE_COMMENT = "//[^\\r\\n]*" ;
skip MULTI_LINE_COMMENT = "/\\*[^*]*\\*+(?:[^*/][^*]*\\*+)*/" ;

// the predefined basic types
leaf identifier          = "[a-zA-Z_][a-zA-Z0-9_]*" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf stringLiteral       = '"' "[^\\"\\\\]*(\\\\.[^\\"\\\\]*)*" '"' ;
leaf numberLiteral       = "[0-9]+";
leaf booleanLiteral      = 'false' | 'true';

}`; // end of grammar
