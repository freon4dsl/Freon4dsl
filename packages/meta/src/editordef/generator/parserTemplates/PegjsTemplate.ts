import {
    PiBinaryExpressionConcept,
    PiClassifier,
    PiConcept,
    PiInterface,
    PiLanguage,
    PiLimitedConcept,
    PiPrimitiveProperty,
    PiProperty
} from "../../../languagedef/metalanguage/PiLanguage";
import { ListJoin, ListJoinType, PiEditConcept, PiEditProjectionText, PiEditSubProjection, PiEditUnit } from "../../metalanguage";
import { findAllImplementorsAndSubs, findImplementors, Names } from "../../../utils";

export const referencePostfix = "PiElemRef";

export class PegjsTemplate {
    referredClassifiers: PiClassifier[] = [];
    textForListConcepts: string[] = [];
    listNumber: number = 0;

    generatePegjsForUnit(language: PiLanguage, langUnit: PiConcept, editDef: PiEditUnit): string {
        this.referredClassifiers = [];
        this.textForListConcepts = [];
        this.listNumber= 0;
        const creatorName = Names.parserCreator(language);

        // Note that the order in which the rules are stated, determines whether the parser is functioning or not
        // first create a rule for the unit, next for its children, etc.
        // the following method stores its result in two lists: one for all editor definitions found, one for all used interfaces
        let sortedEditorDefs: PiEditConcept[] = [];
        let sortedInterfaces: PiInterface[] = [];
        this.findEditorDefsForUnit(langUnit, editDef.conceptEditors, sortedEditorDefs, sortedInterfaces);

        // Template starts here, no prettier for pegjs files, therefore we take indentation into account in this template
        return `// Generated by the ProjectIt Language Generator.

// This file contains the input to the PEG.JS parser generator (see https://pegjs.org). The parser generator 
// is automatically called by the ProjectIt Language Generator and another file with the same name, but with
// extension ".js" is created. The ".js" file contains the actual parser.
// The file with extension ".pegjs" (this file) is stored in order for the parsing rules to be examined.

{
    let creator = require("./${creatorName}");
}
        
${sortedEditorDefs.map(conceptDef => `${this.makeConceptRule(conceptDef)}\n`).join("")}
${sortedInterfaces.map(intf => `${this.makeChoiceRule(intf)}\n`).join("")}
${this.referredClassifiers.map(piClassifier => `${this.makeReferenceRule(piClassifier)}\n`).join("")}
${this.textForListConcepts.map(listRule => `${listRule}\n`).join("")}

ws "whitespace" = (([ \\t\\n\\r]) / (SingleLineComment) / (MultiLineComment) )*
rws "required whitespace" = (([ \\t\\n\\r]) / (SingleLineComment) / (MultiLineComment) )+

variable "variable"
  = first:varLetter rest:identifierChar* { return first + rest.join(""); }

stringLiteral       = "\\"" chars:anyChar* "\\"" { return chars.join(""); }

varLetter           = [a-zA-Z]
identifierChar      = [a-zA-Z0-9_$] // any char but not /.,!?@~%^&*-=+(){}"':;<>?[]\\/
anyChar             = [*a-zA-Z0-9' /\\-[\\]+<>=#$_.,!?@~%^&*-=+(){}:;<>?]
number              = [0-9]

numberLiteral     = nums:number+ { return nums.join(""); }
booleanLiteral    = fbool:"false" \ tbool:"true" { if (!!fbool) { return fbool; } else { return tbool; } }

SingleLineComment
  = "//" (!LineTerminator SourceCharacter)*

LineTerminator
  = [\\n\\r\\u2028\\u2029]

Comment "comment"
  = MultiLineComment
  / SingleLineComment

MultiLineComment
  = "/*" (!"*/" SourceCharacter)* "*/"

SourceCharacter
  = .
  
char
  = unescaped
  / escape
    sequence:(
        '"'
      / "\\\\"
      / "/"
      / "\\["
      / "\\]"
      / "$"
      / "b" { return "\\b"; }
      / "f" { return "\\f"; }
      / "n" { return "\\n"; }
      / "r" { return "\\r"; }
      / "t" { return "\\t"; }
      / "u" digits:$(HEXDIG HEXDIG HEXDIG HEXDIG) {
          return String.fromCharCode(parseInt(digits, 16));
        }
    )
    { return sequence; }

escape
  = "\\\\"

unescaped
  = [^\\0-\\x1F\\x22\\x5C]

// ----- Core ABNF Rules -----

// See RFC 4234, Appendix B (http://tools.ietf.org/html/rfc4234).
DIGIT  = [0-9]
HEXDIG = [0-9a-f]
`;
        // end Template
    }

    private makeConceptRule(conceptDef: PiEditConcept): string {
        const piClassifier: PiConcept = conceptDef.concept.referred;
        if (piClassifier.isModel || piClassifier instanceof PiLimitedConcept) return ``;
        const myName = Names.classifier(piClassifier);
        if (piClassifier.isAbstract) {
            return this.makeChoiceRule(piClassifier);
        } else if (piClassifier instanceof PiBinaryExpressionConcept) {
            return this.makeBinaryExpressionRule(conceptDef, piClassifier);
        } else {
            const propsToSet: PiProperty[] = [];

            conceptDef.projection.lines.forEach(l => {
                l.items.forEach(item => {
                    if (item instanceof PiEditSubProjection) {
                        propsToSet.push(item.expression.findRefOfLastAppliedFeature())
                    }
                });
            });

            // TODO escape all quotes in a text string
            return `${myName} = ${conceptDef.projection.lines.map(l =>
                `${l.items.map(item =>
                    `${(item instanceof PiEditProjectionText) ?
                        `\"${item.text.trim()}\" ws `
                        :
                        `${(item instanceof PiEditSubProjection) ?
                            `${this.makeSubProjectionRule(item)} ws `
                            :
                            ``}`
                    }`).join("")}`
            ).join("\n\t")}\n\t{ return creator.create${myName}({${propsToSet.map(prop => `${prop.name}:${prop.name}`).join(", ")}}); }\n`;
        }
    }

    private makeSubProjectionRule(item: PiEditSubProjection): string {
        const myElem = item.expression.findRefOfLastAppliedFeature();
        if (myElem.isList) {
            this.listNumber++;
            let listRuleName: string;
            if (myElem instanceof PiPrimitiveProperty) {
                listRuleName = Names.startWithUpperCase(myElem.primType) + "List" + this.listNumber;
                // TODO remove this hack when the edit definition includes lists of primitives
                item.listJoin = new ListJoin();
                item.listJoin.joinText = ", ";
                item.listJoin.joinType = ListJoinType.Separator;
                // end hack
            } else {
                if (item.listJoin?.joinType === ListJoinType.Separator) {
                    listRuleName = Names.startWithUpperCase(myElem.type.referred.name) + "List" + this.listNumber;
                } else {
                    listRuleName = Names.startWithUpperCase(myElem.type.referred.name);
                }
            }

            if (item.listJoin?.joinType === ListJoinType.Separator) {
                this.makeRuleForList(item, myElem, listRuleName);
                return `${myElem.name}:${listRuleName} ws `;
            } else {
                if (!myElem.isPart) {
                    listRuleName += referencePostfix;
                    if (!this.referredClassifiers.includes(myElem.type.referred)) {
                        this.referredClassifiers.push(myElem.type.referred);
                    }
                }
                return `${myElem.name}:(${listRuleName} ws "${item.listJoin?.joinText}" ws)* `;
            }
        } else {
            if (myElem instanceof PiPrimitiveProperty) {
                if (myElem.name === "name") {
                    return `${myElem.name}:variable`;
                }
                switch (myElem.primType) {
                    case "string":
                        return `${myElem.name}:stringLiteral ws`;
                    case "boolean":
                        return `${myElem.name}:booleanLiteral ws`;
                    case "number":
                        return `${myElem.name}:numberLiteral ws`;
                }
                return ``;
            } else {
                const typeName = Names.classifier(myElem.type.referred);
                if (myElem.isPart) {
                    return `${myElem.name}:${typeName}`;
                } else { // the property is a reference
                    if (!this.referredClassifiers.includes(myElem.type.referred)) {
                        this.referredClassifiers.push(myElem.type.referred);
                    }
                    return `${myElem.name}:${typeName}${referencePostfix} ws `;
                }
            }
        }
    }

    private makeReferenceRule(piClassifier: PiClassifier): string {
        const myName = Names.classifier(piClassifier);
        return `${myName}${referencePostfix} = name:variable
    { return creator.create${myName}${referencePostfix}({name: name}); }\n`;
    }

    private makeRuleForList(item: PiEditSubProjection, myElem: PiProperty, listRuleName: string) {
        let typeName: string = '';
        if (myElem instanceof PiPrimitiveProperty) {
            // TODO make a difference between variables and stringLiterals
            if (myElem.primType == "string" ) typeName = "stringLiteral";
            if (myElem.primType == "number" ) typeName = "numberLiteral";
            if (myElem.primType == "boolean" ) typeName = "booleanLiteral";
        } else {
            typeName = Names.classifier(myElem.type.referred);
            if (!myElem.isPart) {
                typeName += referencePostfix;
                if (!this.referredClassifiers.includes(myElem.type.referred)) {
                    this.referredClassifiers.push(myElem.type.referred);
                }
            }
        }
        const joinText = (item.listJoin?.joinText ? item.listJoin?.joinText.trimRight() : "NO_JOINTEXT");
        if (item.listJoin?.joinType === ListJoinType.Separator) {
            this.textForListConcepts.push(`${listRuleName} = head:${typeName} tail:("${joinText}" ws v:${typeName} { return v; })*
    { return [head].concat(tail); }\n`);
        }
    }

    private findPartTypesInUnit(langUnit: PiConcept): PiClassifier[] {
        let result: PiClassifier[] = [];
        this.addPartConcepts(langUnit, result);
        return result;
    }

    private addPartConcepts(piClassifier: PiClassifier, result: PiClassifier[]) {
        let typesDone: PiClassifier[] = [];
        if (!result.includes(piClassifier) ) result.push(piClassifier);
        piClassifier.allParts().forEach(part => {
            const type = part.type.referred;
            if (!typesDone.includes(type)) {
                typesDone.push(type);
                if (!result.includes(type)) {
                    if ((type instanceof PiConcept && type.isAbstract) || type instanceof PiInterface) {
                        findAllImplementorsAndSubs(type).forEach(type => {
                            this.addPartConcepts(type, result);
                        });
                    } else {
                        result.push(type);
                        this.addPartConcepts(type, result);
                    }
                }
            }
        });
    }

    private findEditorDefsForUnit(langUnit: PiConcept, conceptEditors: PiEditConcept[], result1: PiEditConcept[], result2: PiInterface[]) {
        const typesUsedInUnit = this.findPartTypesInUnit(langUnit);
        // Again note that the order in which the rules are stated, determines whether the parser is functioning or not
        // first create a rule for the unit, next for its children, etc.
        typesUsedInUnit.forEach(type => {
            if (type instanceof PiConcept) {
                result1.push(...conceptEditors.filter(editor => editor.concept.referred == type));
            } else if (type instanceof  PiInterface) {
                result2.push(type);
            }
        });
    }

    private makeChoiceRule(piClassifier: PiClassifier): string {
        // for interfaces we create a parse rule that is a choice between all classifiers that either implement or extend the interface
        // because limited concepts can only be used as reference, these are excluded for this choice
        // we also need to filter out the interface itself
        // the same is done for abstract concepts
        let implementors: PiClassifier[] = [];
        if (piClassifier instanceof  PiInterface) {
            // TODO should we include a reference to a limited concept in the parse rule for an interface?
            implementors = findImplementors(piClassifier).filter(piCLassifier => !(piCLassifier instanceof PiLimitedConcept));
        } else if (piClassifier instanceof PiConcept) {
            implementors = piClassifier.allSubConceptsDirect().filter(piCLassifier => !(piCLassifier instanceof PiLimitedConcept));
        }

        if (implementors.length > 0 ) {
            return `${Names.classifier(piClassifier)} = ${implementors.map((piClassifier, index) => `var${index}:${Names.classifier(piClassifier)} { return var${index}; }`).join("\n    / ")}\n`;
        } else {
            return `${Names.classifier(piClassifier)} = "ERROR: there are no concepts that implement this interface"\n`;
        }
    }

    private makeBinaryExpressionRule(conceptDef: PiEditConcept, piClassifier: PiBinaryExpressionConcept) {
        const left = piClassifier.allProperties().find(prop => prop.name = "left");
        const right = piClassifier.allProperties().find(prop => prop.name = "right");
        // piClassifier.priority
        const leftRule = Names.classifier(left.type.referred);
        const rightRule = Names.classifier(right.type.referred);
        const symbol = conceptDef.symbol;
        return `${Names.classifier(piClassifier)} = "(" ws ${leftRule} ws "${symbol}" ws ${rightRule} ws ")"`;
    }
}

