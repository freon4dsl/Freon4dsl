import * as fs from "fs";
import parserTypeScript = require("prettier/parser-typescript");
import { MetaLogger } from "../utils/MetaLogger";

const LOGGER = new MetaLogger("FileHelpers").mute();
const prettier = require("prettier/standalone");
const path = require("path");

export class GenerationStatus {
    numberOfErrors: number = 0;
}

export function isNullOrUndefined(obj: Object | null | undefined): obj is null | undefined {
    return obj === undefined || obj === null;
}

export class Helpers {
    public static generateManualFile(pathName: string, contents: string, message: string) {
        if (!fs.existsSync(pathName)) {
            fs.writeFileSync(pathName, contents);
        } else {
            LOGGER.info(this, "projectit-generate-editor: user file " + message + " already exists, skipping it.");
        }
    }

    public static pretty(typescriptFile: string, message: string, status: GenerationStatus): string {
        try {
            // LOGGER.log("Pretty printing generated code");
            return (
                // the meaning of the options to prettier (second parameter) are
                // parser: the language used
                // printWidth: the width of the lines
                // tabWidth: the width of a tab
                // plugins: the programming language used -- adds a predefined plugin for typescript
                // trailingComma: do not use a trailing comma when it can be avoided
                // arrowParens: do not add parenthesis around a sole arrow function parameter, example: (x) => {}
                "// Generated by the ProjectIt Language Generator." + "\n" +
                prettier.format(typescriptFile, {
                    parser: "typescript",
                    printWidth: 140,
                    tabWidth: 4,
                    plugins: [parserTypeScript],
                    trailingComma: "none",
                    arrowParens: "avoid"
                })
            );
        } catch (e) {
            LOGGER.error(this, "Syntax error in generated code: " + message);
            LOGGER.error(this, e.message);
            status.numberOfErrors += 1;
            return "// Generated by the ProjectIt Language Generator." + "\n" + typescriptFile;
        }
    }

    public static createDirIfNotExisting(dir: string) {
        const parts = dir.split("/");
        let current = ".";
        for (const part of parts) {
            current = current + "/" + part;
            if (!fs.existsSync(current)) {
                LOGGER.log("creating folder: [" + dir + "]");
                fs.mkdirSync(current);
            }
        }
    }

    /**
     * files need to be deleted before the new files are generated
     * therefore we use the synchronous 'fs.readdirSync'
     * instead of 'fs.readdir'.
     */
    public static deleteFilesInDir(dir: string, status: GenerationStatus) {
        LOGGER.log("deleting files from folder: [" + dir + "]");
        const folder = "./" + dir;
        if (fs.existsSync(folder)) {
            fs.readdirSync(folder).forEach(file => {
                fs.unlink(path.join(folder, file), err => {
                    LOGGER.log("deleting file: [" + path.join(folder, file) + "]");
                    if (err) {
                        LOGGER.error(this, err.message + " " + err.path);
                        status.numberOfErrors += 1;
                    }
                });
            });
        } else {
            LOGGER.error(this, "Could not find folder: [" + folder + "]");
            status.numberOfErrors += 1;
        }
    }

    public static deleteDirAndContent(dir: string) {
        LOGGER.log("Deleting complete folder and content: [" + dir + "]");
        const folder = "./" + dir;
        if (fs.existsSync(folder)) {
            // all files need to be deleted before the folder can be deleted
            // therefore we use the '..Sync' versions of the 'fs' methods
            fs.readdirSync(folder).forEach(file => {
                fs.unlinkSync(path.join(folder, file));
            });
            fs.rmdirSync(folder);
        // } else {
            // LOGGER.error(this, "Could not find folder: [" + folder + "]");
        }
    }

    public static deleteDirIfEmpty(dir: string) {
        LOGGER.log("Deleting folder only when it is empty: [" + dir + "]");
        const folder = "./" + dir;
        if (fs.existsSync(folder)) {
            if (fs.readdirSync(folder).length == 0) {
                fs.rmdirSync(folder);
            } else  {
                LOGGER.info(this, "Folder has content: [" + folder + "]");
            }
        // } else {
            // LOGGER.error(this, "Could not find folder: [" + folder + "]");
        }
    }

    public static deleteFile(path: string) {
        LOGGER.log("deleting file: [" + path + "]");
        if (fs.existsSync(path)) {
            fs.unlinkSync(path);
        }
    }
    /**
     * startPath: the folder where the files should be located
     * extension: a regular expression to filter the filenames found
     */
    public static findFiles(startPath: string, status: GenerationStatus, extension?: string): string[] {
        if (!fs.existsSync(startPath)) {
            LOGGER.error(this, "cannot find folder '" + startPath + "'");
            status.numberOfErrors += 1;
            return [];
        }
        if (!fs.lstatSync(startPath).isDirectory()) {
            LOGGER.error(this, "'" + startPath + "' is not a folder");
            status.numberOfErrors += 1;
            return [];
        }

        const result: string[] = [];
        const files = fs.readdirSync(startPath);
        for (const file of files) {
            const filename = path.join(startPath, file);
            const stat = fs.lstatSync(filename);
            if (!stat.isDirectory()) {
                if (extension === undefined) {
                    result.push(filename);
                } else {
                    const regex = new RegExp(`\\${extension}\$`);
                    if (regex.test(filename)) {
                        result.push(filename);
                    }
                }
            }
        }
        return result;
    }
}
