import * as fs from "fs";
import synchronizedPrettier from "@prettier/sync";
import { MetaLogger } from "../MetaLogger.js";

const LOGGER = new MetaLogger("FileUtil").mute();
import * as path from 'path';

export class GenerationStatus {
    numberOfErrors: number = 0;
}

export function isNullOrUndefined(obj: Object | null | undefined): obj is null | undefined {
    return obj === undefined || obj === null;
}

export class FileUtil {

    public static separator(): string {
        return path.sep;
    }

    public static generateManualFile(pathName: string, contents: string, message: string) {
        if (!fs.existsSync(pathName)) {
            fs.writeFileSync(pathName, contents);
        } else {
            LOGGER.info("freon-generator: user file " + message + " already exists, skipping it.");
        }
    }

    public static pretty(typescriptFile: string, message: string, status: GenerationStatus): string {
        try {
            // LOGGER.log("Pretty printing generated code");
            return (
                // the meaning of the options to prettier (second parameter) are
                // parser: the language used
                // printWidth: the width of the lines
                // tabWidth: the width of a tab
                // plugins: the programming language used -- adds a predefined plugin for typescript
                // trailingComma: do not use a trailing comma when it can be avoided
                // arrowParens: do not add parenthesis around a sole arrow function parameter, example: (x) => {}
                "// Generated by the Freon Language Generator." + "\n" +
                synchronizedPrettier.format(typescriptFile, {
                    parser: "typescript",
                    plugins: [],
                    printWidth: 140,
                    tabWidth: 4,
                    // todo add the following options to prettier.format, without type error
                    // trailingComma: "none",
                    // arrowParens: "avoid",
                })
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                LOGGER.error("Syntax error in generated code: " + message);
                LOGGER.error(e.message);
                status.numberOfErrors += 1;
            }
            return "// Generated by the Freon Language Generator." + "\n" + typescriptFile;
        }
    }

    public static createDirIfNotExisting(dir: string) {
        const parts = dir.split("/");
        let current = ".";
        for (const part of parts) {
            current = current + "/" + part;
            if (!fs.existsSync(current)) {
                LOGGER.log("creating folder: [" + dir + "]");
                fs.mkdirSync(current);
            }
        }
    }

    /**
     * files need to be deleted before the new files are generated
     * therefore we use the synchronous 'fs.readdirSync'
     * instead of 'fs.readdir'.
     */
    public static deleteFilesInDir(dir: string, status: GenerationStatus) {
        LOGGER.log("deleting files from folder: [" + dir + "]");
        const folder = "./" + dir;
        if (fs.existsSync(folder)) {
            fs.readdirSync(folder).forEach(file => {
                const completePath = path.join(folder, file);
                if (!fs.lstatSync(completePath).isDirectory()) {
                    fs.unlink(completePath, err => {
                        LOGGER.log("deleting file: [" + completePath + "]");
                        if (err) {
                            LOGGER.error(err.message + " " + err.path);
                            status.numberOfErrors += 1;
                        }
                    });
                }
            });
        } else {
            LOGGER.error("Could not find folder: [" + folder + "]");
            status.numberOfErrors += 1;
        }
    }

    public static deleteDirAndContent(dir: string) {
        LOGGER.log("Deleting complete folder and content: [" + dir + "]");
        const folder = "./" + dir;
        if (fs.existsSync(folder)) {
            // all files need to be deleted before the folder can be deleted
            // therefore we use the '..Sync' versions of the 'fs' methods
            fs.readdirSync(folder).forEach(file => {
                fs.unlinkSync(path.join(folder, file));
            });
            fs.rmdirSync(folder);
        // } else {
            // LOGGER.error("Could not find folder: [" + folder + "]");
        }
    }

    public static deleteDirIfEmpty(dir: string) {
        LOGGER.log("Deleting folder only when it is empty: [" + dir + "]");
        const folder = "./" + dir;
        if (fs.existsSync(folder)) {
            if (fs.readdirSync(folder).length === 0) {
                fs.rmdirSync(folder);
            } else {
                LOGGER.info("Folder has content: [" + folder + "]");
            }
        // } else {
            // LOGGER.error("Could not find folder: [" + folder + "]");
        }
    }

    public static deleteFile (filePath: string) {
        LOGGER.log("deleting file: [" + filePath + "]");
        if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
        }
    }
    /**
     * startPath: the folder where the files should be located
     * extension: a regular expression to filter the filenames found
     */
    public static findFiles(startPath: string, status: GenerationStatus, extension?: string): string[] {
        if (!fs.existsSync(startPath)) {
            LOGGER.error("cannot find folder '" + startPath + "'");
            status.numberOfErrors += 1;
            return [];
        }
        if (!fs.lstatSync(startPath).isDirectory()) {
            LOGGER.error("'" + startPath + "' is not a folder");
            status.numberOfErrors += 1;
            return [];
        }

        const result: string[] = [];
        const files = fs.readdirSync(startPath);
        for (const file of files) {
            const filename = path.join(startPath, file);
            const stat = fs.lstatSync(filename);
            if (!stat.isDirectory()) {
                if (extension === undefined) {
                    result.push(filename);
                } else {
                    const regex = new RegExp(`\\${extension}\$`);
                    if (regex.test(filename)) {
                        result.push(filename);
                    }
                }
            }
        }
        return result;
    }
}
