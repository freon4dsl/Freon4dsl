// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Checking parser generation on abstract concepts and interfaces 1`] = `
"// Generated by the Freon Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by Test4ModelUnitReader

export const Test4GrammarStr = \`
namespace Test4Language
grammar Test4Grammar {

// rules for \\"TEST_CHOICES\\"
TEST_CHOICES = Aa
	 Bb
	 __fre_super_Cc
	 __fre_super_Dd
	 Ee
	 Ff ;

Bb = 'BB' ;

Dd = 'DD' ;

Cc = 'CC' ;

Ff = 'FF' ;

Ee = 'EE' ;

Aa = Bb 
    | __fre_super_Dd  ;

Yy = Ee 
    | __fre_super_Dd  ;

__fre_super_Dd = Dd 
    | __fre_super_Cc  ;

__fre_super_Cc = Cc 
    | Ff  ;

// common rules

__fre_reference = [ identifier / '.' ]+ ;

// white space and comments
skip WHITE_SPACE = \\"\\\\\\\\s+\\" ;
skip SINGLE_LINE_COMMENT = \\"//[^\\\\\\\\r\\\\\\\\n]*\\" ;
skip MULTI_LINE_COMMENT = \\"/\\\\\\\\*[^*]*\\\\\\\\*+(?:[^*/][^*]*\\\\\\\\*+)*/\\" ;

// the predefined basic types
leaf identifier          = \\"[a-zA-Z_][a-zA-Z0-9_]*\\" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf stringLiteral       = '\\"' \\"[^\\\\\\\\\\"\\\\\\\\\\\\\\\\]*(\\\\\\\\\\\\\\\\.[^\\\\\\\\\\"\\\\\\\\\\\\\\\\]*)*\\" '\\"' ;
leaf numberLiteral       = \\"[0-9]+\\";
leaf booleanLiteral      = 'false' | 'true';

}\`; // end of grammar
"
`;

exports[`Checking parser generation on list properties 1`] = `
"// Generated by the Freon Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by Test3ModelUnitReader

export const Test3GrammarStr = \`
namespace Test3Language
grammar Test3Grammar {

// rules for \\"TEST_LISTS\\"
TEST_LISTS = Aa
	 Bb
	 Cc
	 Dd
	 Ee
	 Ff
	 Gg
	 Hh ;

Aa = SomeConcept* ;

SomeConcept = identifier ':' numberLiteral ;

Bb = [ SomeConcept / '%' ]* ;

Cc = ( SomeConcept '%' )* ;

Dd = ( '%' SomeConcept )* ;

Ee = __fre_reference* ;

Ff = [ __fre_reference / '%' ]* ;

Gg = ( __fre_reference '%' )* ;

Hh = ( '%' __fre_reference )* ;

// common rules

__fre_reference = [ identifier / '.' ]+ ;

// white space and comments
skip WHITE_SPACE = \\"\\\\\\\\s+\\" ;
skip SINGLE_LINE_COMMENT = \\"//[^\\\\\\\\r\\\\\\\\n]*\\" ;
skip MULTI_LINE_COMMENT = \\"/\\\\\\\\*[^*]*\\\\\\\\*+(?:[^*/][^*]*\\\\\\\\*+)*/\\" ;

// the predefined basic types
leaf identifier          = \\"[a-zA-Z_][a-zA-Z0-9_]*\\" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf stringLiteral       = '\\"' \\"[^\\\\\\\\\\"\\\\\\\\\\\\\\\\]*(\\\\\\\\\\\\\\\\.[^\\\\\\\\\\"\\\\\\\\\\\\\\\\]*)*\\" '\\"' ;
leaf numberLiteral       = \\"[0-9]+\\";
leaf booleanLiteral      = 'false' | 'true';

}\`; // end of grammar
"
`;

exports[`Checking parser generation on primitives 1`] = `
"// Generated by the Freon Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by Test1ModelUnitReader

export const Test1GrammarStr = \`
namespace Test1Language
grammar Test1Grammar {

// rules for \\"TEST_PRIMS\\"
TEST_PRIMS = Aa
	 Bb
	 Cc
	 Dd
	 Ee
	 Ff
	 Gg
	 Hh
	 Jj ;

Aa = 'single'? ;

Bb = ( 'double1' | 'double2' ) ;

Cc = numberLiteral ;

Dd = numberLiteral ;

Ee = numberLiteral? ;

Ff = numberLiteral* ;

Gg = [ numberLiteral / '=' ]* ;

Hh = ( numberLiteral '=' )* ;

Jj = ( '=' numberLiteral )* ;

// common rules

__fre_reference = [ identifier / '.' ]+ ;

// white space and comments
skip WHITE_SPACE = \\"\\\\\\\\s+\\" ;
skip SINGLE_LINE_COMMENT = \\"//[^\\\\\\\\r\\\\\\\\n]*\\" ;
skip MULTI_LINE_COMMENT = \\"/\\\\\\\\*[^*]*\\\\\\\\*+(?:[^*/][^*]*\\\\\\\\*+)*/\\" ;

// the predefined basic types
leaf identifier          = \\"[a-zA-Z_][a-zA-Z0-9_]*\\" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf stringLiteral       = '\\"' \\"[^\\\\\\\\\\"\\\\\\\\\\\\\\\\]*(\\\\\\\\\\\\\\\\.[^\\\\\\\\\\"\\\\\\\\\\\\\\\\]*)*\\" '\\"' ;
leaf numberLiteral       = \\"[0-9]+\\";
leaf booleanLiteral      = 'false' | 'true';

}\`; // end of grammar
"
`;

exports[`Checking parser generation on single properties 1`] = `
"// Generated by the Freon Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by Test2ModelUnitReader

export const Test2GrammarStr = \`
namespace Test2Language
grammar Test2Grammar {

// rules for \\"TEST_SINGLES\\"
TEST_SINGLES = Aa
	 Bb1
	 Bb2
	 Cc
	 Dd
	 Ee1
	 Ee2
	 Ff ;

Aa = SomeConcept? ;

SomeConcept = identifier ':' numberLiteral ;

Bb1 = SomeConcept? ;

Bb2 = 'xxx' SomeConcept? ;

Cc = SomeConcept ;

Dd = __fre_reference? ;

Ee1 = __fre_reference? ;

Ee2 = 'xxx' __fre_reference? ;

Ff = __fre_reference* ;

// common rules

__fre_reference = [ identifier / '.' ]+ ;

// white space and comments
skip WHITE_SPACE = \\"\\\\\\\\s+\\" ;
skip SINGLE_LINE_COMMENT = \\"//[^\\\\\\\\r\\\\\\\\n]*\\" ;
skip MULTI_LINE_COMMENT = \\"/\\\\\\\\*[^*]*\\\\\\\\*+(?:[^*/][^*]*\\\\\\\\*+)*/\\" ;

// the predefined basic types
leaf identifier          = \\"[a-zA-Z_][a-zA-Z0-9_]*\\" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf stringLiteral       = '\\"' \\"[^\\\\\\\\\\"\\\\\\\\\\\\\\\\]*(\\\\\\\\\\\\\\\\.[^\\\\\\\\\\"\\\\\\\\\\\\\\\\]*)*\\" '\\"' ;
leaf numberLiteral       = \\"[0-9]+\\";
leaf booleanLiteral      = 'false' | 'true';

}\`; // end of grammar
"
`;
