// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Checking parser generation > on abstract concepts and interfaces 1`] = `
"// Generated by the Freon Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by TEST4ModelUnitReader

export const TEST4GrammarStr = \`
namespace TEST4Language
grammar TEST4Grammar {

// rules for "TEST_CHOICES"
TEST_CHOICES = Aa
	 Bb
	 __fre_super_Cc
	 __fre_super_Dd
	 Ee
	 Ff ;

Bb = 'BB' ;

Dd = 'DD' ;

Cc = 'CC' ;

Ff = 'FF' ;

Ee = 'EE' ;

Aa = Bb 
    | __fre_super_Dd  ;

Yy = Ee 
    | __fre_super_Dd  ;

__fre_super_Dd = Dd 
    | __fre_super_Cc  ;

__fre_super_Cc = Cc 
    | Ff  ;

// common rules

__fre_reference = [ identifier / '.' ]+ ;

// white space and comments
skip WHITE_SPACE = "\\\\s+" ;
skip SINGLE_LINE_COMMENT = "//[^\\\\r\\\\n]*" ;
skip MULTI_LINE_COMMENT = "/\\\\*[^*]*\\\\*+(?:[^*/][^*]*\\\\*+)*/" ;

// the predefined basic types
leaf identifier        = "\\\`[a-zA-Z0-9-_~!@#$%^&*()+={\\\\[}\\\\]|\\:;\\\\"'<>,.?/][a-zA-Z0-9-_~!@#$%^&*()+={\\\\[}\\\\]|\\:;\\\\"'<>,.?/]*\\\`" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf optStringLiteral  = "<no-value>" | stringLiteral ;
leaf stringLiteral     = '"' "[^\\\\"\\\\\\\\]*(\\\\\\\\.[^\\\\"\\\\\\\\]*)*" '"' ;
leaf optNumberLiteral  = "<no-value>" | numberLiteral;
leaf numberLiteral     = "[0-9]+";
leaf optBooleanLiteral = "<no-value>" | booleanLiteral;
leaf booleanLiteral    = 'false' | 'true';

}\`; // end of grammar
"
`;

exports[`Checking parser generation > on list properties 1`] = `
"// Generated by the Freon Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by TEST3ModelUnitReader

export const TEST3GrammarStr = \`
namespace TEST3Language
grammar TEST3Grammar {

// rules for "TEST_LISTS"
TEST_LISTS = Aa
	 Bb
	 Cc
	 Dd
	 Ee
	 Ff
	 Gg
	 Hh ;

Aa = SomeConcept* ;

SomeConcept = identifier ':' numberLiteral ;

Bb = [ SomeConcept / '%' ]* ;

Cc = ( SomeConcept '%' )* ;

Dd = ( '%' SomeConcept )* ;

Ee = __fre_reference* ;

Ff = [ __fre_reference / '%' ]* ;

Gg = ( __fre_reference '%' )* ;

Hh = ( '%' __fre_reference )* ;

// common rules

__fre_reference = [ identifier / '.' ]+ ;

// white space and comments
skip WHITE_SPACE = "\\\\s+" ;
skip SINGLE_LINE_COMMENT = "//[^\\\\r\\\\n]*" ;
skip MULTI_LINE_COMMENT = "/\\\\*[^*]*\\\\*+(?:[^*/][^*]*\\\\*+)*/" ;

// the predefined basic types
leaf identifier        = "\\\`[a-zA-Z0-9-_~!@#$%^&*()+={\\\\[}\\\\]|\\:;\\\\"'<>,.?/][a-zA-Z0-9-_~!@#$%^&*()+={\\\\[}\\\\]|\\:;\\\\"'<>,.?/]*\\\`" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf optStringLiteral  = "<no-value>" | stringLiteral ;
leaf stringLiteral     = '"' "[^\\\\"\\\\\\\\]*(\\\\\\\\.[^\\\\"\\\\\\\\]*)*" '"' ;
leaf optNumberLiteral  = "<no-value>" | numberLiteral;
leaf numberLiteral     = "[0-9]+";
leaf optBooleanLiteral = "<no-value>" | booleanLiteral;
leaf booleanLiteral    = 'false' | 'true';

}\`; // end of grammar
"
`;

exports[`Checking parser generation > on primitives 1`] = `
"// Generated by the Freon Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by TEST1ModelUnitReader

export const TEST1GrammarStr = \`
namespace TEST1Language
grammar TEST1Grammar {

// rules for "TEST_PRIMS"
TEST_PRIMS = Aa
	 Bb
	 Cc
	 Dd
	 Ee
	 Ff
	 Gg
	 Hh
	 Jj ;

Aa = 'single'? ;

Bb = ( 'double1' | 'double2' ) ;

Cc = numberLiteral ;

Dd = numberLiteral ;

Ee = numberLiteral? ;

Ff = numberLiteral* ;

Gg = [ numberLiteral / '=' ]* ;

Hh = ( numberLiteral '=' )* ;

Jj = ( '=' numberLiteral )* ;

// common rules

__fre_reference = [ identifier / '.' ]+ ;

// white space and comments
skip WHITE_SPACE = "\\\\s+" ;
skip SINGLE_LINE_COMMENT = "//[^\\\\r\\\\n]*" ;
skip MULTI_LINE_COMMENT = "/\\\\*[^*]*\\\\*+(?:[^*/][^*]*\\\\*+)*/" ;

// the predefined basic types
leaf identifier        = "\\\`[a-zA-Z0-9-_~!@#$%^&*()+={\\\\[}\\\\]|\\:;\\\\"'<>,.?/][a-zA-Z0-9-_~!@#$%^&*()+={\\\\[}\\\\]|\\:;\\\\"'<>,.?/]*\\\`" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf optStringLiteral  = "<no-value>" | stringLiteral ;
leaf stringLiteral     = '"' "[^\\\\"\\\\\\\\]*(\\\\\\\\.[^\\\\"\\\\\\\\]*)*" '"' ;
leaf optNumberLiteral  = "<no-value>" | numberLiteral;
leaf numberLiteral     = "[0-9]+";
leaf optBooleanLiteral = "<no-value>" | booleanLiteral;
leaf booleanLiteral    = 'false' | 'true';

}\`; // end of grammar
"
`;

exports[`Checking parser generation > on single properties 1`] = `
"// Generated by the Freon Language Generator.
// This file contains the input to the AGL parser generator
// (see https://https://github.com/dhakehurst/net.akehurst.language).
// The grammar in this file is read by TEST2ModelUnitReader

export const TEST2GrammarStr = \`
namespace TEST2Language
grammar TEST2Grammar {

// rules for "TEST_SINGLES"
TEST_SINGLES = Aa
	 Bb1
	 Bb2
	 Cc
	 Dd
	 Ee1
	 Ee2
	 Ff ;

Aa = SomeConcept? ;

SomeConcept = identifier ':' numberLiteral ;

Bb1 = SomeConcept? ;

Bb2 = 'xxx' SomeConcept? ;

Cc = SomeConcept ;

Dd = __fre_reference? ;

Ee1 = __fre_reference? ;

Ee2 = 'xxx' __fre_reference? ;

Ff = __fre_reference* ;

// common rules

__fre_reference = [ identifier / '.' ]+ ;

// white space and comments
skip WHITE_SPACE = "\\\\s+" ;
skip SINGLE_LINE_COMMENT = "//[^\\\\r\\\\n]*" ;
skip MULTI_LINE_COMMENT = "/\\\\*[^*]*\\\\*+(?:[^*/][^*]*\\\\*+)*/" ;

// the predefined basic types
leaf identifier        = "\\\`[a-zA-Z0-9-_~!@#$%^&*()+={\\\\[}\\\\]|\\:;\\\\"'<>,.?/][a-zA-Z0-9-_~!@#$%^&*()+={\\\\[}\\\\]|\\:;\\\\"'<>,.?/]*\\\`" ;
/* see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java */
leaf optStringLiteral  = "<no-value>" | stringLiteral ;
leaf stringLiteral     = '"' "[^\\\\"\\\\\\\\]*(\\\\\\\\.[^\\\\"\\\\\\\\]*)*" '"' ;
leaf optNumberLiteral  = "<no-value>" | numberLiteral;
leaf numberLiteral     = "[0-9]+";
leaf optBooleanLiteral = "<no-value>" | booleanLiteral;
leaf booleanLiteral    = 'false' | 'true';

}\`; // end of grammar
"
`;
