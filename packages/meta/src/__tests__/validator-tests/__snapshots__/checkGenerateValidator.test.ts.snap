// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Checking the validator generator > validator file for 'test-correct1' is correctly generated 1`] = `
"// Generated by the Freon Language Generator.
// TEMPLATE: RulesCheckerTemplate.generateRulesChecker(...)

import { FreError, FreErrorSeverity, FreCompositeTyper, type FreWriter, FreLanguageEnvironment, isNullOrUndefined } from "@freon4dsl/core";
import { AAAAAA, ZZ, BB, DD } from "../../language/gen/index.js";

import { ROOTDefaultWorker } from "../../utils/gen/index.js";
import { reservedWordsInTypescript } from "./ReservedWords.js";

import { type ROOTCheckerInterface } from "./ROOTValidator.js";

/**
 * Class ROOTValidationRulesChecker is the part of validator that is generated from, if present,
 * the validator definition. As the other checkers, it uses the visitor pattern.
 * Class ROOTDefaultWorker implements the traversal of the model tree. This class implements
 * the actual checking of each node in the tree.
 */
export class ROOTValidationRulesChecker extends ROOTDefaultWorker implements ROOTCheckerInterface {
    // 'myWriter' is used to provide error messages on the nodes in the model tree
    myWriter: FreWriter = FreLanguageEnvironment.getInstance().writer;
    // 'typer' is used to implement the 'typecheck' rules in the validator definition
    typer: FreCompositeTyper = FreLanguageEnvironment.getInstance().typer;
    // 'errorList' holds the errors found while traversing the model tree
    errorList: FreError[] = [];

    /**
     * Checks 'node' before checking its children.
     * Found errors are pushed onto 'errorList'.
     * @param node
     */
    public execBeforeAAAAAA(node: AAAAAA): boolean {
        let hasFatalError: boolean = false;

        // self.AAprop3 >= 10
        if (!(node.AAprop3 >= 10)) {
            this.errorList.push(new FreError("'self.AAprop3 >= 10' is false", node, node.name, FreErrorSeverity.ToDo));
        }
        // isunique BBprop15 in self.AAprop8
        let uniqueBBprop15InAAprop8: ZZ[] = [];
        node.AAprop8.forEach((elem: BB, index: number) => {
            if (isNullOrUndefined(elem)) {
                this.errorList.push(
                    new FreError(
                        \`Element[\${index}] of property 'AAprop8' has no value\`,
                        node.AAprop8[index],
                        node.name,
                        "BBprop15",
                        FreErrorSeverity.ToDo,
                    ),
                );
            } else {
                if (!uniqueBBprop15InAAprop8.includes(elem.$BBprop15)) {
                    uniqueBBprop15InAAprop8.push(elem.$BBprop15);
                } else {
                    this.errorList.push(
                        new FreError(
                            \`The value of property 'BBprop15' ("\${this.myWriter.writeNameOnly(elem)}") is not unique in list 'AAprop8'\`,
                            node.AAprop8[index],
                            node.name,
                            "BBprop15",
                            FreErrorSeverity.ToDo,
                        ),
                    );
                }
            }
        });
        // notEmpty self.AAprop2
        if (node.AAprop2.length === 0) {
            this.errorList.push(
                new FreError("List 'self.AAprop2' may not be empty", node, node.name, "self.AAprop2", FreErrorSeverity.ToDo),
            );
        }
        // notEmpty self.AAprop10
        if (node.$AAprop10.length === 0) {
            this.errorList.push(
                new FreError("List 'self.AAprop10' may not be empty", node, node.name, "self.AAprop10", FreErrorSeverity.ToDo),
            );
        }
        // isunique self.DDprop4 in self.AAprop12
        let uniqueDDprop4InAAprop12: number[] = [];
        node.AAprop12.forEach((elem: DD, index: number) => {
            if (isNullOrUndefined(elem)) {
                this.errorList.push(
                    new FreError(
                        \`Element[\${index}] of property 'AAprop12' has no value\`,
                        node.AAprop12[index],
                        node.name,
                        "DDprop4",
                        FreErrorSeverity.ToDo,
                    ),
                );
            } else {
                if (!uniqueDDprop4InAAprop12.includes(elem.DDprop4)) {
                    uniqueDDprop4InAAprop12.push(elem.DDprop4);
                } else {
                    this.errorList.push(
                        new FreError(
                            \`The value of property 'DDprop4' ("\${this.myWriter.writeNameOnly(elem)}") is not unique in list 'AAprop12'\`,
                            node.AAprop12[index],
                            node.name,
                            "DDprop4",
                            FreErrorSeverity.ToDo,
                        ),
                    );
                }
            }
        });
        // validIdentifier name
        if (!this.isValidName(node.name)) {
            this.errorList.push(new FreError("'" + node.name + "' is not a valid identifier", node, node.name, FreErrorSeverity.ToDo));
        }
        return hasFatalError;
    }

    /**
     * Returns true if 'name' is a valid identifier
     * @param name
     */
    private isValidName(name: string): boolean {
        if (isNullOrUndefined(name)) return false;
        // cannot start with number
        if (/[0-9]/.test(name[0])) return false;
        // may contain letters, numbers, '$', and '_', but no other characters
        if (/[.|,!?@~%^&*|-|=+(){}"':;<>]/.test(name)) return false;
        if (/\\\\/.test(name)) return false;
        // may not contain whitespaces
        if (/[\\t\\n\\r ]/.test(name)) return false;
        // may not be a Typescript keyword
        return !reservedWordsInTypescript.includes(name);
    }
}
"
`;
