import type { FreMetaLanguage} from '../../metalanguage/index.js';
import { FreMetaClassifier, FreMetaLimitedConcept, LangUtil } from '../../metalanguage/index.js';
import { Names, STDLIB_FOLDER, Imports } from "../../../utils/on-lang/index.js"
import { GenerationUtil } from '../../../utils/on-lang/GenerationUtil.js';

export class LanguageTemplate {
    generateLanguage(language: FreMetaLanguage, relativePath: string): string {
        const imports = new Imports(relativePath)
        imports.core = new Set<string>([
            Names.FreLanguage,
            "FreLanguageModel",
            "FreLanguageModelUnit", 
            "FreLanguageProperty",
            "FreLanguageConcept",
            "FreLanguageInterface",
            Names.FreNodeReference
        ])
        return `
            // Generated by Freon LanguageTemplate
            ${imports.makeImports(language)}
            // Import as MyLanguage to avoid naming conflicts in generated constructors
            import * as MyLanguage from "./internal.js";
            import { ${Names.stdlib(language)} } from "${relativePath}/${STDLIB_FOLDER}/${Names.stdlib(language)}.js";

            /**
             * Creates an in-memory representation of structure of the language metamodel, used in e.g. the (de)serializer.
             */
             export function initializeLanguage() {
                ${Names.FreLanguage}.getInstance().name = "${language.name}";
                ${Names.FreLanguage}.getInstance().languageVersion = "${language.modelConcept.version}";
                ${Names.FreLanguage}.getInstance().id = ${language.id !== undefined ? `"${language.id}"` : `"${language.name}"`};
                ${Names.FreLanguage}.getInstance().addModel(describe${Names.classifier(language.modelConcept)}());
                ${language.units
                    .map(
                        (concept) =>
                            `${Names.FreLanguage}.getInstance().addUnit(describe${Names.classifier(concept)}());`,
                    )
                    .join("\n")}
                ${language.concepts
                    .map(
                        (concept) =>
                            `${Names.FreLanguage}.getInstance().addConcept(describe${Names.concept(concept)}());`,
                    )
                    .join("\n")}
                ${language.interfaces
                    .map(
                        (intface) =>
                            `${Names.FreLanguage}.getInstance().addInterface(describe${Names.interface(intface)}());`,
                    )
                    .join("\n")}
                ${Names.FreLanguage}.getInstance().addReferenceCreator( (name: string, type: string) => {
                    return (!!name ? ${Names.FreNodeReference}.create(name, type) : null);
                });
                ${Names.FreLanguage}.getInstance().stdLib = ${Names.stdlib(language)}.getInstance();
            }

            function describe${Names.classifier(language.modelConcept)}(): FreLanguageModel {
                    const model: FreLanguageModel<MyLanguage.${Names.classifier(language.modelConcept)}> = {
                        typeName: "${Names.classifier(language.modelConcept)}",
                        id: "${language.modelConcept.id}",
                        key: "${language.modelConcept.key}",
                        isNamespace: true,
                        language: "${language.modelConcept.language.key}",
                        constructor: (id?: string) => { return new MyLanguage.${Names.classifier(language.modelConcept)}(id); },
                        creator: (data: Partial<MyLanguage.${Names.classifier(language.modelConcept)}>) => { return MyLanguage.${Names.classifier(language.modelConcept)}.create(data); },
                        properties: new Map< string, FreLanguageProperty>(),
                    }
                    ${language.modelConcept
                        .allPrimProperties()
                        .map(
                            (prop) =>
                                `model.properties.set("${prop.name}", {
                                        name: "${prop.name}",
                                        id: "${prop.id}",
                                        key: "${prop.key}",
                                        type: "${GenerationUtil.getBaseTypeAsString(prop)}",
                                        isList: ${prop.isList},
                                        isPublic: ${prop.isPublic},
                                        isOptional: ${prop.isOptional},
                                        language: "${prop.language.key}",
                                        propertyKind: "primitive"
                                    });`,
                        )
                        .join("\n")}
                    ${language.modelConcept
                        .allParts()
                        .map(
                            (prop) =>
                                `model.properties.set("${prop.name}", {
                                        name: "${prop.name}",
                                        id: "${prop.id}",
                                        key: "${prop.key}",
                                        type: "${Names.classifier(prop.type)}",
                                        isList: ${prop.isList},
                                        isPublic: ${prop.isPublic},
                                        isOptional: ${prop.isOptional},
                                        language: "${prop.language.key}",
                                        propertyKind: "part"
                                    });`,
                        )
                        .join("\n")}
                    ${language.modelConcept
                        .allReferences()
                        .map(
                            (prop) =>
                                `model.properties.set("${prop.name}", {
                                        name: "${prop.name}",
                                        id: "${prop.id}",
                                        key: "${prop.key}",
                                        type: "${Names.classifier(prop.type)}",
                                        isList: ${prop.isList},
                                        isPublic: ${prop.isPublic},
                                        isOptional: ${prop.isOptional},
                                        language: "${prop.language.key}",
                                        propertyKind: "reference"
                                    });`,
                        )
                        .join("\n")}
                        // Type cast is here to avoid function-parameter variance issue:
                        // function parameters are contravariant: a function that 
                        // accepts a more specific param is not assignable to one 
                        // that claims it can accept a broader param.
                        return model as unknown as FreLanguageModel;
                    }

            ${language.units
                .map(
                    (modelunit) =>
                        `
                function describe${Names.classifier(modelunit)}(): FreLanguageModelUnit {
                    const modelunit: FreLanguageModelUnit<MyLanguage.${Names.classifier(modelunit)}> =             {
                        typeName: "${Names.classifier(modelunit)}",
                        id: "${modelunit.id}",
                        key: "${modelunit.key}",
                        isNamedElement: true,
                        isNamespace: false,
                        language: "${modelunit.language.key}",
                        fileExtension: "${modelunit.fileExtension}",
                        subConceptNames: [], // Nothing yet, but may change in the future
                        constructor: (id?: string) => { return new MyLanguage.${Names.classifier(modelunit)}(id); },
                        creator: (data: Partial<MyLanguage.${Names.classifier(modelunit)}>) => { return MyLanguage.${Names.classifier(modelunit)}.create(data); },
                        properties: new Map< string, FreLanguageProperty>(),
                        trigger: "${Names.classifier(modelunit)}"
                    }
                    ${modelunit
                        .allPrimProperties()
                        .map(
                            (prop) =>
                                `modelunit.properties.set("${prop.name}", {
                                        name: "${prop.name}",
                                        id: "${prop.id}",
                                        key: "${prop.key}",
                                        type: "${GenerationUtil.getBaseTypeAsString(prop)}",
                                        isList: ${prop.isList},
                                        isPublic: ${prop.isPublic},
                                        isOptional: ${prop.isOptional},
                                        language: "${prop.language.key}",
                                        propertyKind: "primitive"
                                    });`,
                        )
                        .join("\n")}
                            ${modelunit
                                .allParts()
                                .map(
                                    (prop) =>
                                        `modelunit.properties.set("${prop.name}", {
                                        name: "${prop.name}",
                                        id: "${prop.id}",
                                        key: "${prop.key}",
                                        type: "${Names.classifier(prop.type)}",
                                        isList: ${prop.isList},
                                        isPublic: ${prop.isPublic},
                                        isOptional: ${prop.isOptional},
                                        language: "${prop.language.key}",
                                        propertyKind: "part"
                                    });`,
                                )
                                .join("\n")}
                            ${modelunit
                                .allReferences()
                                .map(
                                    (prop) =>
                                        `modelunit.properties.set("${prop.name}", {
                                        name: "${prop.name}",
                                        id: "${prop.id}",
                                        key: "${prop.key}",
                                        type: "${Names.classifier(prop.type)}",
                                        isList: ${prop.isList},
                                        isPublic: ${prop.isPublic},
                                        isOptional: ${prop.isOptional},
                                        language: "${prop.language.key}",
                                        propertyKind: "reference"
                                    });`,
                                )
                                .join("\n")}
                        // Type cast is here to avoid function-parameter variance issue:
                        // function parameters are contravariant: a function that 
                        // accepts a more specific param is not assignable to one 
                        // that claims it can accept a broader param.
                        return modelunit as unknown as FreLanguageModelUnit;
                    }`,
                )
                .join("\n")}

            ${language.concepts
                .map(
                    (concept) =>
                        `
                function describe${Names.concept(concept)}(): FreLanguageConcept {
                    const concept: FreLanguageConcept<MyLanguage.${Names.concept(concept)}> =             {
                        typeName: "${Names.concept(concept)}",
                        id: "${concept.id}",
                        key: "${concept.key}",
                        isAbstract: ${concept.isAbstract},
                        isPublic: ${concept.isPublic},
                        isLimited: ${concept instanceof FreMetaLimitedConcept},
                        isNamespace: false,
                        instanceNames: ${concept instanceof FreMetaLimitedConcept ? `[${concept.instances.map((inst) => `"${inst.name}"`)}]` : "[]"},
                        language: "${concept.originalOwningLanguage.key}",
                        isNamedElement: ${concept.allPrimProperties().some((p) => p.name === "name")},
                        trigger: "${Names.concept(concept)}",
                        constructor: (id?: string) => { return ${concept.isAbstract ? "undefined" : `new MyLanguage.${Names.concept(concept)}(id)`}; },
                        creator: (data: Partial<MyLanguage.${Names.concept(concept)}>) => { return ${concept.isAbstract ? "undefined" : `MyLanguage.${Names.concept(concept)}.create(data)`}; },
                        properties: new Map< string, FreLanguageProperty>(),
                        baseName: ${!!concept.base ? `"${Names.classifier(concept.base.referred)}"` : "undefined"},
                        subConceptNames: [${FreMetaClassifier.subConcepts(concept)
                            .map((sub) => '"' + Names.classifier(sub) + '"')
                            .join(", ")}]
                    }
                    ${concept
                        .allPrimProperties()
                        .map(
                            (prop) =>
                                `concept.properties.set("${prop.name}", {
                                name: "${prop.name}",
                                id: "${prop.id}",
                                key: "${prop.key}",
                                type: "${GenerationUtil.getBaseTypeAsString(prop)}",
                                isList: ${prop.isList},
                                isOptional: ${prop.isOptional},
                                isPublic: ${prop.isPublic},
                                language: "${prop.language.key}",
                                propertyKind: "primitive"
                            });`,
                        )
                        .join("\n")}
                    ${concept
                        .allParts()
                        .map(
                            (prop) =>
                                `concept.properties.set("${prop.name}", {
                                name: "${prop.name}",
                                id: "${prop.id}",
                                key: "${prop.key}",
                                type: "${Names.classifier(prop.type)}",
                                isList: ${prop.isList},
                                isPublic: ${prop.isPublic},
                                isOptional: ${prop.isOptional},
                                language: "${prop.language.key}",
                                propertyKind: "part"
                            });`,
                        )
                        .join("\n")}
                    ${concept
                        .allReferences()
                        .map(
                            (prop) =>
                                `concept.properties.set("${prop.name}", {
                                name: "${prop.name}",
                                id: "${prop.id}",
                                key: "${prop.key}",
                                type: "${Names.classifier(prop.type)}",
                                isList: ${prop.isList},
                                isPublic: ${prop.isPublic},
                                isOptional: ${prop.isOptional},
                                language: "${prop.language.key}",
                                propertyKind: "reference"
                            });`,
                        )
                        .join("\n")}
                    // Type cast is here to avoid function-parameter variance issue:
                    // function parameters are contravariant: a function that 
                    // accepts a more specific param is not assignable to one 
                    // that claims it can accept a broader param.
                    return concept as unknown as FreLanguageConcept;
            }`,
                )
                .join("\n")}
            ${language.interfaces
                .map(
                    (intface) =>
                        `
                function describe${Names.interface(intface)}(): FreLanguageInterface {
                    const intface: FreLanguageInterface =             {
                        typeName: "${Names.interface(intface)}",
                        id: "${intface.id}",
                        key: "${intface.key}",
                        isPublic: ${intface.isPublic},
                        isNamedElement: ${intface.allPrimProperties().some((p) => p.name === "name")},
                        isNamespace: false,
                        properties: new Map< string, FreLanguageProperty>(),
                        language: "${intface.originalOwningLanguage.NAME}",
                        subConceptNames: [${LangUtil.subClassifiers(intface)
                            .map((sub) => '"' + Names.classifier(sub) + '"')
                            .join(", ")}]
                    }
                ${intface
                    .allPrimProperties()
                    .map(
                        (prop) =>
                            `intface.properties.set("${prop.name}", {
                                name: "${prop.name}",
                                id: "${prop.id}",
                                key: "${prop.key}",
                                type: "${GenerationUtil.getBaseTypeAsString(prop)}",
                                isList: ${prop.isList},
                                isPublic: ${prop.isPublic},
                                isOptional: ${prop.isOptional},
                                language: "${prop.language.NAME}",
                                propertyKind: "primitive"
                            });`,
                    )
                    .join("\n")}
                ${intface
                    .allParts()
                    .map(
                        (prop) =>
                            `intface.properties.set("${prop.name}", {
                                name: "${prop.name}",
                                id: "${prop.id}",
                                key: "${prop.key}",
                                type: "${Names.classifier(prop.type)}",
                                isList: ${prop.isList},
                                isPublic: ${prop.isPublic},
                                isOptional: ${prop.isOptional},
                                language: "${prop.language.NAME}",
                                propertyKind: "part"
                            });`,
                    )
                    .join("\n")}
                ${intface
                    .allReferences()
                    .map(
                        (prop) =>
                            `intface.properties.set("${prop.name}", {
                                name: "${prop.name}",
                                id: "${prop.id}",
                                key: "${prop.key}",
                                type: "${Names.classifier(prop.type)}",
                                isList: ${prop.isList},
                                isPublic: ${prop.isPublic},
                                isOptional: ${prop.isOptional},
                                language: "${prop.language.NAME}",
                                propertyKind: "reference"
                            });`,
                    )
                    .join("\n")}
                    // Type cast is here to avoid function-parameter variance issue:
                    // function parameters are contravariant: a function that 
                    // accepts a more specific param is not assignable to one 
                    // that claims it can accept a broader param.
                    return intface as unknown as FreLanguageConcept;
            }`,
                )
                .join("\n")}
        `;
    }
}
